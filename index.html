<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <title>Three Body Problem Simulator</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
        background-color: #000;
        color: #fff;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        touch-action: manipulation; /* Prevents double-tap to zoom */
      }
      
      #container {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        margin: auto;
      }
      
      #ui-toggle {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 1000;
        background-color: rgba(30, 39, 46, 0.85);
        color: #ecf0f1;
        border: none;
        border-radius: 8px;
        padding: 8px 12px;
        cursor: pointer;
        font-size: 14px;
        backdrop-filter: blur(5px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        transition: all 0.2s ease;
      }
      
      #ui-toggle:hover {
        background-color: rgba(40, 49, 56, 0.9);
      }
      
      .ui-hidden .controls-panel,
      .ui-hidden #help-text,
      .ui-hidden #mass-controls,
      .ui-hidden #speedControls,
      .ui-hidden #camera-container,
      .ui-hidden #resetButtonRow,
      .ui-hidden #controls,
      .ui-hidden #camera-controls {
        display: none !important;
      }
      
      /* Mobile and touch styles */
      @media (pointer: coarse) {
        .button {
          padding: 12px 18px !important;
          margin: 6px !important;
          min-width: 80px;
        }
        
        .button-row {
          justify-content: center;
          width: 100%;
        }
        
        /* Ensure all buttons are visible */
        #controls {
          max-width: 95% !important;
        }
        
        .mass-slider {
          height: 30px !important;
        }
        
        .mass-slider::-webkit-slider-thumb {
          width: 24px !important;
          height: 24px !important;
        }
        
        input[type="number"], input[type="range"] {
          padding: 8px !important;
        }
        
        #controls, #mass-controls, #camera-controls, #speed-controls {
          max-width: none !important;
          width: 90% !important;
        }
        
        .toggle-controls, .toggle-speed, .toggle-camera, .toggle-mass {
          font-size: 24px !important;
          padding: 8px !important;
        }
      }
      
      /* iPad-specific adjustments */
      @media only screen and (min-device-width: 768px) and (max-device-width: 1024px) {
        #controls {
          top: 20px;
          left: 20px;
          max-width: 360px !important;
        }
        
        #mass-controls {
          top: 20px;
          right: 20px;
          max-width: 360px !important;
          max-height: 90vh;
        }
        
        #camera-controls {
          bottom: 30px;
          left: 20px;
          max-width: 360px !important;
        }
        
        .speed-controls {
          top: 20px;
          left: 50%;
          transform: translateX(-50%);
          max-width: 440px !important;
        }
        
        #help-text {
          bottom: 20px;
          right: 20px;
          width: 300px;
        }
        
        .button {
          padding: 10px 16px !important;
          font-size: 16px !important;
        }
      }
      
      /* Fixed 16:9 aspect ratio container */
      #container {
        position: relative;
        width: 100%;
        max-width: 177.78vh; /* 16:9 aspect ratio */
        height: 100%;
        max-height: 56.25vw; /* 16:9 aspect ratio */
        margin: auto;
      }
      
      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }
      
      #controls {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: rgba(30, 39, 46, 0.85);
        padding: 15px;
        border-radius: 8px;
        z-index: 100;
        max-width: 340px;
        backdrop-filter: blur(5px);
      }
      
      .control-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        margin-bottom: 10px;
      }
      
      .control-header h3 {
        margin: 0;
        color: #ecf0f1;
      }
      
      .toggle-controls, .toggle-speed, .toggle-camera, .toggle-mass {
        font-size: 16px;
        background: none !important;
        border: none;
        color: #ecf0f1;
        cursor: pointer;
        padding: 0 !important;
        margin: 0 !important;
      }
      
      .control-content {
        overflow: hidden;
        transition: max-height 0.3s ease-out;
        max-height: 1000px;
      }
      
      .control-content.collapsed {
        max-height: 0;
      }
      
      .button {
        display: inline-block;
        margin: 5px;
        padding: 8px 15px;
        background-color: #2c3e50;
        color: #fff;
        text-decoration: none;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      
      .button:hover {
        background-color: #34495e;
      }
      
      .button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      
      #startButton {
        background-color: #2980b9;
      }
      
      #startButton:hover {
        background-color: #3498db;
      }
      
      #stopButton {
        background-color: #c0392b;
      }
      
      #stopButton:hover {
        background-color: #e74c3c;
      }
      
      #pauseButton {
        background-color: #8e44ad;
      }
      
      #pauseButton:hover {
        background-color: #9b59b6;
      }
      
      #resetLastButton {
        background-color: #16a085;
      }
      
      #resetLastButton:hover {
        background-color: #1abc9c;
      }
      
      #resetDefaultButton {
        background-color: #2c3e50;
      }
      
      #resetDefaultButton:hover {
        background-color: #34495e;
      }
      
      #toggleTrailsButton {
        background-color: #7f8c8d;
      }
      
      #toggleTrailsButton:hover {
        background-color: #95a5a6;
      }
      
      input[type="number"], input[type="range"] {
        width: 100px;
        margin: 5px;
        padding: 5px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }
      
      .body-controls {
        margin-top: 15px;
        border-top: 1px solid rgba(255, 255, 255, 0.3);
        padding-top: 10px;
        transition: height 0.3s, opacity 0.3s;
        overflow: hidden;
      }
      
      .body-controls.hidden {
        height: 0;
        opacity: 0;
        padding: 0;
        margin: 0;
        pointer-events: none;
      }
      
      .body-section {
        margin-bottom: 5px; /* Reduced from 10px */
        padding: 6px; /* Reduced from 8px */
        border-radius: 4px;
        background-color: rgba(255, 255, 255, 0.1);
      }
      
      .mass-slider-container {
        display: flex;
        align-items: center;
        margin: 5px 0; /* Reduced from 10px 0 */
      }
      
      .mass-slider {
        flex-grow: 1;
        height: 6px;
        -webkit-appearance: none;
        background: rgba(255, 255, 255, 0.3);
        outline: none;
        border-radius: 3px;
        margin: 0 5px 0 0; /* Changed from 0 10px */
      }
      
      .mass-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        cursor: pointer;
      }
      
      #body1MassSlider::-webkit-slider-thumb {
        background: #d8a0ff;
      }
      
      #body2MassSlider::-webkit-slider-thumb {
        background: #ffb6c1;
      }
      
      #body3MassSlider::-webkit-slider-thumb {
        background: #87cefa;
      }
      
      .mass-value {
        width: 30px;
        text-align: center;
      }
      
      .velocity-inputs {
        margin-top: 5px;
      }
      
      /* Hide the original number inputs that we're replacing */
      .hidden-input {
        display: none;
      }
      
      /* Instructions tooltip */
      .tooltip {
        position: absolute;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 0.9em;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s;
        width: max-content;
        max-width: 200px;
        z-index: 100;
      }
      
      /* Styles for draggable elements */
      .draggable {
        cursor: move;
      }
      
      /* Re-add camera controls styles */
      #camera-controls {
        position: absolute;
        bottom: 40px;
        left: 10px;
        background-color: rgba(30, 39, 46, 0.85);
        padding: 10px;
        padding-top: 0;
        border-radius: 8px;
        z-index: 100;
        backdrop-filter: blur(5px);
        max-height: 200px;
        transition: max-height 0.3s ease-out;
        overflow: hidden;
      }
      
      #camera-controls.collapsed {
        max-height: 40px;
      }
      
      .camera-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        padding: 5px 10px;
      }
      
      .camera-header h4 {
        margin: 5px 0;
        color: #ecf0f1;
      }
      
      .camera-content {
        padding: 5px 0;
        overflow: hidden;
      }
      
      #camera-controls.collapsed .camera-content {
        height: 0;
        padding: 0;
      }
      
      .toggle-camera {
        font-size: 16px;
        background: none !important;
        border: none;
        color: white;
        cursor: pointer;
        padding: 0 !important;
        margin: 0 !important;
      }
      
      #status {
        position: absolute;
        bottom: 10px;
        right: 10px;
        padding: 8px 15px;
        background-color: rgba(0, 0, 0, 0.7);
        border-radius: 8px;
        backdrop-filter: blur(5px);
      }
      
      /* Remove the simulation time display */
      #simulation-time {
        display: none;
      }
      
      .button-group {
        margin-bottom: 15px;
      }
      
      .button-row {
        display: flex;
        justify-content: center;
        margin-bottom: 8px;
        flex-wrap: wrap;
        min-height: 40px; /* Ensure row maintains height even when buttons are hidden */
      }
      
      .button-row:last-child {
        margin-bottom: 0;
      }
      
      .button-row .button {
        margin: 0 5px 5px 5px;
      }
      
      /* iPad-specific adjustments for button rows */
      @media only screen and (min-device-width: 768px) and (max-device-width: 1024px) {
        .button-row {
          justify-content: center;
        }
        
        .button-row .button {
          min-width: 100px;
        }
      }
      
      .preset-config {
        margin: 15px 0;
        padding: 10px;
        background-color: rgba(255, 255, 255, 0.1);
        border-radius: 5px;
      }
      
      .select-dropdown {
        width: 100%;
        padding: 8px;
        margin-top: 5px;
        margin-bottom: 8px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        border: 1px solid #555;
        border-radius: 4px;
        cursor: pointer;
      }
      
      .select-dropdown:focus {
        outline: none;
        border-color: #4caf50;
      }
      
      /* Re-style the instructions panel for better positioning */
      #help-text {
        position: absolute;
        bottom: 10px;
        right: 20vw;
        background-color: rgba(30, 39, 46, 0.85);
        padding: 15px;
        border-radius: 8px;
        z-index: 100;
        width: 260px;
        backdrop-filter: blur(5px);
        transition: all 0.3s ease-out;
        overflow: hidden;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }
      
      #help-text.hidden {
        opacity: 0;
        visibility: hidden;
        transform: translateY(20px);
      }
      
      .help-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        margin-bottom: 8px;
      }
      
      .help-header h4 {
        margin: 0;
        color: #ecf0f1;
        font-size: 1.1em;
        font-weight: bold;
      }
      
      .help-content {
        overflow: hidden;
        transition: max-height 0.3s ease-out;
        max-height: 1000px;
        font-size: 0.95em;
      }
      
      .help-content.collapsed {
        max-height: 0;
        overflow: hidden;
      }
      
      .toggle-help {
        font-size: 16px;
        background: none !important;
        border: none;
        color: #ecf0f1;
        cursor: pointer;
        padding: 0 !important;
        margin: 0 !important;
      }
      
      #help-text ol {
        margin: 0 0 0.8em 1.2em;
        padding: 0;
      }
      
      #help-text ul {
        margin: 0 0 0.5em 1.2em;
        padding: 0;
        list-style: disc;
      }
      
      #help-text li {
        margin-bottom: 3px;
      }
      
      #help-text h5 {
        margin: 8px 0 5px 0;
        color: #ff5252;
      }
      
      #mass-controls {
        position: absolute;
        top: 10px;
        right: 10px;
        background-color: rgba(30, 39, 46, 0.85);
        padding: 8px; /* Reduced from 10px */
        padding-top: 0;
        border-radius: 8px;
        z-index: 100;
        max-width: 340px;
        backdrop-filter: blur(5px);
        max-height: 98vh; /* Use viewport height to ensure it fits */
        overflow-y: auto; /* Add scrolling if needed */
        transition: max-height 0.3s ease-out;
      }
      
      #mass-controls.collapsed {
        max-height: 40px;
        overflow-y: hidden;
      }
      
      #mass-controls.collapsed .mass-content {
        height: 0;
        padding: 0;
      }
      
      .mass-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        margin-bottom: 5px; /* Reduced from default value */
      }
      
      .mass-header h4 {
        color: #ecf0f1;
        margin: 5px 0;
      }
      
      .mass-content {
        overflow: hidden;
        transition: max-height 0.3s ease-out;
        max-height: 1000px;
      }
      
      .toggle-mass {
        font-size: 16px;
        background: none !important;
        border: none;
        color: #ecf0f1;
        cursor: pointer;
        padding: 0 !important;
        margin: 0 !important;
      }
      
      .speed-controls {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(30, 39, 46, 0.85);
        padding: 10px;
        padding-top: 0;
        border-radius: 8px;
        z-index: 100;
        backdrop-filter: blur(5px);
        text-align: center;
        max-height: 200px;
        transition: max-height 0.3s ease-out;
        overflow: hidden;
      }
      
      .speed-controls.collapsed {
        max-height: 40px;
      }
      
      .speed-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        padding: 5px 10px;
      }
      
      .speed-header h4 {
        margin: 5px 0;
        color: #ecf0f1;
      }
      
      .toggle-speed {
        font-size: 16px;
        background: none;
        border: none;
        color: white;
        cursor: pointer;
      }
      
      .speed-button {
        background-color: #2c3e50;
        color: #fff;
        border: 2px solid transparent;
        border-radius: 4px;
        padding: 8px 15px;
        margin: 5px;
        cursor: pointer;
        transition: all 0.2s;
      }
      
      .speed-button:hover {
        background-color: #34495e;
      }
      
      .speed-active {
        border: 2px solid #ecf0f1 !important;
        box-shadow: 0 0 8px rgba(149, 165, 166, 0.7);
      }
      
      #slowSpeedButton {
        background-color: #1a237e;
      }
      
      #slowSpeedButton:hover {
        background-color: #283593;
      }
      
      #normalSpeedButton {
        background-color: #0d47a1;
      }
      
      #normalSpeedButton:hover {
        background-color: #1565c0;
      }
      
      #fastSpeedButton {
        background-color: #4a148c;
      }
      
      #fastSpeedButton:hover {
        background-color: #6a1b9a;
      }
      
      #veryFastSpeedButton {
        background-color: #880e4f;
      }
      
      #veryFastSpeedButton:hover {
        background-color: #ad1457;
      }
      
      #superFastSpeedButton {
        background-color: #b71c1c;
      }
      
      #superFastSpeedButton:hover {
        background-color: #c62828;
      }
      
      #freePlayButton {
        background-color: #006064;
      }
      
      #freePlayButton:hover {
        background-color: #00838f;
      }
      
      #freePlayButton.active {
        border: 2px solid #ecf0f1 !important;
        background-color: #00acc1;
        box-shadow: 0 0 8px rgba(0, 172, 193, 0.7);
      }
      
      #camera-controls button {
        margin: 5px;
        padding: 8px 15px;
        background-color: #263238;
        color: #fff;
        text-decoration: none;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
      
      #camera-controls button:hover {
        background-color: #37474f;
      }
      
      #topViewButton {
        background-color: #01579b;
      }
      
      #topViewButton:hover {
        background-color: #0277bd;
      }
      
      #sideViewButton {
        background-color: #4a148c;
      }
      
      #sideViewButton:hover {
        background-color: #6a1b9a;
      }
      
      #angledViewButton {
        background-color: #1b5e20;
      }
      
      #angledViewButton:hover {
        background-color: #2e7d32;
      }
      
      #followBody1Button {
        background-color: #b71c1c;
      }
      
      #followBody1Button:hover {
        background-color: #c62828;
      }
      
      #followBody2Button {
        background-color: #4527a0;
      }
      
      #followBody2Button:hover {
        background-color: #5e35b1;
      }
      
      #followBody3Button {
        background-color: #01579b;
      }
      
      #followBody3Button:hover {
        background-color: #0288d1;
      }
      
      .speed-content {
        padding: 5px 0;
        overflow: hidden;
      }
      
      .speed-controls.collapsed .speed-content {
        height: 0;
        padding: 0;
      }
      
      /* Style the Cinematic Mode button differently */
      #cinematicButton {
        border: 1px solid #ffffff !important; /* Thicker white border with !important to override any other styles */
        color: #ffffff;
        font-weight: bold;
        letter-spacing: 0.5px;
        text-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
        border-radius: 2px;
        box-shadow: 0 0 8px rgba(255, 255, 255, 0.3);
        position: relative;
        overflow: hidden;
        transform: translateY(0); /* Base state for hover effect */
        transition: all 0.2s ease-out;
      }
      
      #cinematicButton:hover {
        background-color: #6a1b9a; /* Different hover color */
        box-shadow: 0 0 12px rgba(255, 255, 255, 0.5);
        transform: translateY(-1px); /* Slight lift effect on hover */
      }
      
      #cinematicButton.active {
        border: 2px solid #ecf0f1 !important;
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.7);
      }
      
      /* Make sure real-time velocity displays are always visible */
      .realtime-velocity {
        margin-top: 5px;
        padding: 6px 8px;
        background-color: rgba(0, 0, 0, 0.4);
        border-radius: 4px;
        font-size: 0.9em;
        border-left: 3px solid rgba(255, 255, 255, 0.3);
        font-weight: bold;
        width: calc(100% - 16px);
        box-sizing: border-box;
        font-family: monospace;
        min-width: 200px;
        display: block !important; /* Ensure always visible */
      }
      
      .velocity-content {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      
      .velocity-text {
        margin-right: 5px; /* Reduced from 10px */
        font-size: 0.85em; /* Slightly smaller text */
      }
      
      .velocity-arrow-container {
        width: 28px; /* Reduced from 30px */
        height: 35px; /* Reduced from 30px */
        position: relative;
        flex-shrink: 0;
        display: flex;
        justify-content: flex-start;
        align-items: flex-start;
        margin-bottom: 10px;
        margin-right: 10px;
      }
      
      .velocity-arrow {
        position: absolute;
        top: 10%;
        left: 30%;
        width: 0;
        height: 0;
        transform-origin: 0 0;
        transform-origin: center left;
      }
      
      /* Arrow heads for each body type */
      .velocity-arrow.body1 {
        border-left: 20px solid #d8a0ff;
        border-top: 4px solid transparent;
        border-bottom: 4px solid transparent;
      }
      
      .velocity-arrow.body2 {
        border-left: 20px solid #ffb6c1;
        border-top: 4px solid transparent;
        border-bottom: 4px solid transparent;
      }
      
      .velocity-arrow.body3 {
        border-left: 20px solid #87cefa;
        border-top: 4px solid transparent;
        border-bottom: 4px solid transparent;
      }
      
      /* Style for new camera preset buttons */
      #wideViewButton {
        background-color: #00695c;
      }
      
      #wideViewButton:hover {
        background-color: #00897b;
      }
      
      #superWideViewButton {
        background-color: #006064;
      }
      
      #superWideViewButton:hover {
        background-color: #00838f;
      }
      
      /* Small speed buttons for the main control panel */
      .speed-button-small {
        display: inline-block;
        margin: 2px;
        padding: 4px 6px;
        background-color: #2c3e50;
        color: #fff;
        font-size: 11px;
        text-decoration: none;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      
      .speed-button-small:hover {
        background-color: #34495e;
      }
      
      .speed-button-small.speed-active {
        border: 2px solid #ecf0f1;
        box-shadow: 0 0 4px rgba(149, 165, 166, 0.7);
      }
      
      .speed-row {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        margin-top: 8px;
        padding-top: 5px;
        border-top: 1px solid rgba(255, 255, 255, 0.2);
      }
      
      #slowSpeedButton-small {
        background-color: #1a237e;
      }
      
      #normalSpeedButton-small {
        background-color: #0d47a1;
      }
      
      #fastSpeedButton-small {
        background-color: #006064;
      }
      
      #veryFastSpeedButton-small {
        background-color: #004d40;
      }
      
      #superFastSpeedButton-small {
        background-color: #33691e;
      }
      
      #speedControls {
        display: none;
      }
    </style>
    <script
      async
      src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"
    ></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
          "lodash": "https://cdn.jsdelivr.net/npm/lodash@4.17.21/+esm",
          "gsap": "https://cdn.jsdelivr.net/npm/gsap@3.12.4/+esm",
          "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/+esm",
          "d3": "https://cdn.jsdelivr.net/npm/d3@7.8.5/+esm",
          "chart.js": "https://cdn.jsdelivr.net/npm/chart.js@4.4.0/+esm"
        }
      }
    </script>
  </head>
  <body>
    <div id="container">
      <!-- Canvas will be inserted here by Three.js -->
      
    <div id="controls">
        <div class="control-header" id="controlHeader">
          <h3>Three Body Problem Simulator</h3>
          <button class="toggle-controls" id="toggleControlsButton">▼</button>
        </div>
        <div class="control-content" id="controlContent">
          <div class="button-group">
            <!-- Row 1: Start, Stop, Pause -->
            <div class="button-row">
              <button id="startButton" class="button">Start</button>
              <button id="stopButton" class="button">Stop</button>
              <button id="pauseButton" class="button">Pause</button>
            </div>
            
            <!-- Row 2: Reset buttons -->
            <div class="button-row" id="resetButtonRow" style="display: none;">
              <button id="resetDefaultButton" class="button">Reset (Default)</button>
              <button id="resetLastButton" class="button">Reset (Previous)</button>
            </div>
            
            <!-- Row 3: Toggle Borderless and Hide Trails -->
            <div class="button-row">
              <button id="freePlayButton" class="button">Toggle Borderless</button>
              <button id="toggleTrailsButton" class="button">Hide Trails</button>
            </div>
            
            <!-- Row 4: Speed buttons -->
            <div class="speed-row">
              <button id="slowSpeedButton-small" class="speed-button-small">Slow</button>
              <button id="normalSpeedButton-small" class="speed-button-small speed-active">Normal</button>
              <button id="fastSpeedButton-small" class="speed-button-small">Fast</button>
              <button id="veryFastSpeedButton-small" class="speed-button-small">V.Fast</button>
              <button id="superFastSpeedButton-small" class="speed-button-small">S.Fast</button>
            </div>
          </div>
        </div>
    </div>
    
    <div class="speed-controls" id="speedControls">
      <div class="speed-header" id="speedHeader">
        <h4>Simulation Speed</h4>
        <button class="toggle-speed" id="toggleSpeedButton">▼</button>
      </div>
      <div class="speed-content" id="speedContent">
        <button id="slowSpeedButton" class="speed-button">Slow</button>
        <button id="normalSpeedButton" class="speed-button speed-active">Normal</button>
        <button id="fastSpeedButton" class="speed-button">Fast</button>
        <button id="veryFastSpeedButton" class="speed-button">Very Fast</button>
        <button id="superFastSpeedButton" class="speed-button">Super Fast</button>
      </div>
    </div>

    <div id="camera-controls">
      <div class="camera-header" id="cameraHeader">
        <h4>Camera Controls</h4>
        <button class="toggle-camera" id="toggleCameraButton">▼</button>
      </div>
      <div class="camera-content" id="cameraContent">
        <button id="topViewButton">Top View</button>
        <button id="sideViewButton">Side View</button>
        <button id="angledViewButton">Angled View</button>
        <button id="wideViewButton">Wide View</button>
        <button id="superWideViewButton">Super Wide</button>
        <div style="margin-top: 5px;">
          <button id="followBody1Button">Follow Body 1</button>
          <button id="followBody2Button">Follow Body 2</button>
          <button id="followBody3Button">Follow Body 3</button>
          <button id="cinematicButton">Cinematic Mode</button>
        </div>
      </div>
    </div>
    
    <div id="help-text">
      <div class="help-header" id="helpHeader">
        <h4>Instructions</h4>
        <button class="toggle-help" id="toggleHelpButton">▲</button>
      </div>
      <div class="help-content collapsed" id="helpContent">
        <ol>
          <li><strong>Drag bodies</strong> to position them</li>
          <li><strong>Drag arrows</strong> to set velocity</li>
          <li><strong>Adjust sliders</strong> to set mass</li>
          <li>Click <strong>Start</strong> to begin simulation</li>
        </ol>
        <h5>DON'T COLLIDE!</h5>
        <ul>
          <li>Click and drag to rotate view</li>
          <li>Scroll to zoom in/out</li>
          <li>The orbit is stable by default</li>
          <li>Try subtle changes for interesting orbits</li>
          <li>Adjust parameters during simulation</li>
        </ul>
      </div>
    </div>

    <div id="mass-controls">
      <div class="mass-header" id="massHeader">
        <h4>Body Controls</h4>
        <button class="toggle-mass" id="toggleMassButton">▼</button>
      </div>
      <div class="mass-content" id="massContent">
        <div class="body-controls" id="bodyControls">
          <div class="body-section" style="border-left: 4px solid #d8a0ff;">
            <label>Body 1 Mass:</label>
            <div class="mass-slider-container">
              <input type="range" id="body1MassSlider" class="mass-slider" min="0" max="100" step="1" value="20">
              <span class="mass-value" id="body1MassValue">1.0</span>
            </div>
            <input type="number" id="body1Mass" value="1" step="0.1" min="0.1" max="100" class="hidden-input">
            
            <div class="velocity-inputs">
              <input type="number" id="body1VelocityX" value="0" step="0.1" class="hidden-input">
              <input type="number" id="body1VelocityZ" value="0.5" step="0.1" class="hidden-input">
              <div id="body1RealTimeVelocity" class="realtime-velocity">
                Velocity:
                <div class="velocity-content">
                  <div class="velocity-text">X: 0.00&nbsp;&nbsp;Y: 0.00</div>
                  <div class="velocity-arrow-container">
                    <div id="body1VelocityArrow" class="velocity-arrow body1"></div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <div class="body-section" style="border-left: 4px solid #ffb6c1;">
            <label>Body 2 Mass:</label>
            <div class="mass-slider-container">
              <input type="range" id="body2MassSlider" class="mass-slider" min="0" max="100" step="1" value="20">
              <span class="mass-value" id="body2MassValue">1.0</span>
            </div>
            <input type="number" id="body2Mass" value="1" step="0.1" min="0.1" max="100" class="hidden-input">
            
            <div class="velocity-inputs">
              <input type="number" id="body2VelocityX" value="0" step="0.1" class="hidden-input">
              <input type="number" id="body2VelocityZ" value="-0.5" step="0.1" class="hidden-input">
              <div id="body2RealTimeVelocity" class="realtime-velocity">
                Velocity:
                <div class="velocity-content">
                  <div class="velocity-text">X: 0.00&nbsp;&nbsp;Y: 0.00</div>
                  <div class="velocity-arrow-container">
                    <div id="body2VelocityArrow" class="velocity-arrow body2"></div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <div class="body-section" style="border-left: 4px solid #87cefa;">
            <label>Body 3 Mass:</label>
            <div class="mass-slider-container">
              <input type="range" id="body3MassSlider" class="mass-slider" min="0" max="100" step="1" value="20">
              <span class="mass-value" id="body3MassValue">1.0</span>
            </div>
            <input type="number" id="body3Mass" value="1" step="0.1" min="0.1" max="100" class="hidden-input">
            
            <div class="velocity-inputs">
              <input type="number" id="body3VelocityX" value="0.5" step="0.1" class="hidden-input">
              <input type="number" id="body3VelocityZ" value="0" step="0.1" class="hidden-input">
              <div id="body3RealTimeVelocity" class="realtime-velocity">
                Velocity:
                <div class="velocity-content">
                  <div class="velocity-text">X: 0.00&nbsp;&nbsp;Y: 0.00</div>
                  <div class="velocity-arrow-container">
                    <div id="body3VelocityArrow" class="velocity-arrow body3"></div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { DragControls } from "three/addons/controls/DragControls.js";
      import _ from "lodash";
      import { gsap } from "gsap";

      // ------------------------------------------------
      // Constants and configuration
      // ------------------------------------------------
      const BOUNDARY_RADIUS = 60; // Defines the outer circular boundary
      const G = 0.3; // Base gravitational constant
      let simulationSpeed = 0.3; // Default simulation speed (increased by 20% from 0.25)
      let freePlayMode = false; // Track if Borderless Mode is active
      const BODY_COLORS = [
        0xd8a0ff, // Light purple for Body A
        0xffb6c1, // Light pink for Body B
        0x87cefa  // Light blue for Body C
      ];
      const TRAIL_COLORS = [
        { start: 0xd8a0ff, end: 0x8a2be2 }, // Light purple → Dark purple gradient
        { start: 0xffb6c1, end: 0xff1493 }, // Light pink → Dark pink gradient
        { start: 0x87cefa, end: 0x0000cd }  // Light blue → Dark blue gradient
      ];

      // ------------------------------------------------
      // Scene setup
      // ------------------------------------------------
      // Create a container with 16:9 aspect ratio
      const container = document.getElementById('container');
      const aspectRatio = 16 / 9;
      
      // Determine size based on window dimensions
      let width, height;
      if (window.innerWidth / window.innerHeight > aspectRatio) {
        // Window is wider than 16:9
        height = window.innerHeight;
        width = height * aspectRatio;
      } else {
        // Window is taller than 16:9
        width = window.innerWidth;
        height = width / aspectRatio;
      }

      // Initialize scene, camera, and renderer
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(width, height);
      renderer.setPixelRatio(window.devicePixelRatio);
      container.appendChild(renderer.domElement);

      // Set initial camera position and controls
      camera.position.set(0, 42, 50);
      camera.lookAt(0, 0, 0);
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      
      // Configure touch controls
      const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      if (isTouchDevice) {
        controls.rotateSpeed = 0.7; // Slower rotation for more precision on touch
        controls.zoomSpeed = 1.2;   // Slightly faster zoom on touch
        controls.touchStart = function(event) {
          // Handle multitouch interactions more intuitively
          if (event.touches.length === 2) {
            // Two-finger touch - force zoom instead of rotate
            this.handleTouchStartDolly(event);
          } else {
            // Single-finger touch - normal behavior
            this.handleTouchStartRotate(event);
          }
        };
      }
      
      // Ensure camera controls are always enabled
      controls.enabled = true;
      controls.enableZoom = true;
      controls.enableRotate = true;
      
      // Disable features we don't want
      controls.enableKeys = false;
      controls.enablePan = false;

      // ------------------------------------------------
      // Lighting and environment
      // ------------------------------------------------
      // Add ambient and directional light
      const ambientLight = new THREE.AmbientLight(0x404040);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(0, 10, 10);
      scene.add(directionalLight);

      // Create a starfield background
      function createStarfield() {
        const starGeometry = new THREE.BufferGeometry();
        const starCount = 15000; // Increased from 5000
        const starPositions = [];
        const starSizes = [];
        
        for (let i = 0; i < starCount; i++) {
          // Create stars in a spherical distribution
          const radius = 100 + Math.random() * 300; // Increased radius range from 100+100 to 100+300
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          
          const x = radius * Math.sin(phi) * Math.cos(theta);
          const y = radius * Math.sin(phi) * Math.sin(theta);
          const z = radius * Math.cos(phi);
          
          starPositions.push(x, y, z);
          starSizes.push(Math.random() * 2);
        }
        
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
        starGeometry.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));
        
        const starMaterial = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 0.5,
          sizeAttenuation: true
        });
        
        const starField = new THREE.Points(starGeometry, starMaterial);
        scene.add(starField);
      }
      
      createStarfield();

      // Create the circular boundary plane
      function createBoundaryPlane() {
        const planeGeometry = new THREE.CircleGeometry(BOUNDARY_RADIUS, 64);
        const planeMaterial = new THREE.MeshStandardMaterial({
          color: 0x222222,
          transparent: true,
          opacity: 0.5,
          roughness: 0.7
        });
        
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2; // Rotate to horizontal
        plane.position.y = 0;
        scene.add(plane);
        
        // Add a grid on top of the plane for reference
        const gridHelper = new THREE.GridHelper(BOUNDARY_RADIUS * 2, 20);
        gridHelper.position.y = 0.01; // Slightly above the plane
        scene.add(gridHelper);

        // Add a ring to highlight the boundary
        const ringGeometry = new THREE.RingGeometry(BOUNDARY_RADIUS - 0.1, BOUNDARY_RADIUS, 64);
        const ringMaterial = new THREE.MeshBasicMaterial({
          color: 0x3498db,
          side: THREE.DoubleSide
        });
        
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.rotation.x = -Math.PI / 2; // Rotate to horizontal
        ring.position.y = 0.02; // Slightly above the plane
        scene.add(ring);
        
        // Store references for later use
        window.boundaryGrid = gridHelper;
        window.boundaryRing = ring;
        
        // Create large plane and grid for free play mode but keep them hidden initially
        // 4x larger plane for Free Play mode
        const largeGridHelper = new THREE.GridHelper(BOUNDARY_RADIUS * 8, 80);
        largeGridHelper.position.y = 0.01; // Slightly above the plane
        largeGridHelper.material.opacity = 0.2;
        largeGridHelper.material.transparent = true;
        largeGridHelper.visible = false; // Hidden by default
        scene.add(largeGridHelper);
        
        // Large plane for the expanded area
        const largePlaneGeometry = new THREE.CircleGeometry(BOUNDARY_RADIUS * 4, 64);
        const largePlaneMaterial = new THREE.MeshStandardMaterial({
          color: 0x222222,
          transparent: true,
          opacity: 0.2,
          roughness: 0.7
        });
        
        const largePlane = new THREE.Mesh(largePlaneGeometry, largePlaneMaterial);
        largePlane.rotation.x = -Math.PI / 2; // Rotate to horizontal
        largePlane.position.y = -0.01; // Slightly below the normal plane to avoid z-fighting
        largePlane.visible = false; // Hidden by default
        scene.add(largePlane);
        
        // Store references
        window.largeGrid = largeGridHelper;
        window.largePlane = largePlane;
        
        return plane;
      }
      
      const boundaryPlane = createBoundaryPlane();

      // ------------------------------------------------
      // Simulation state
      // ------------------------------------------------
      let masses = [1, 1, 1];
      let initialVelocities = [
        new THREE.Vector3(0, 0, 0.5),
        new THREE.Vector3(0, 0, -0.5),
        new THREE.Vector3(0, 0, 0),
      ];
      let initialPositions = [
        new THREE.Vector3(-5, 0, 0),
        new THREE.Vector3(5, 0, 0),
        new THREE.Vector3(0, 0, 0),
      ];

      // Simulation controls
      let isAnimating = false;
      let isPaused = false;
      let showTrails = true; // Show trails by default
      let simulationTime = 0;
      let animationId;
      let isFollowing = false;
      let followingBodyIndex = 0; // Which body to follow (0, 1, or 2)
      let collisionOccurred = false;
      let cinematicMode = false; // Track if cinematic camera mode is enabled

      // Trail parameters
      const MAX_TRAIL_LENGTH = 5000; // Fixed trail length
      let trails = [[], [], []];
      let trailMeshes = [null, null, null]; // Store trail meshes

      // Bodies
      let bodies = [];
      let bodyMeshes = [];
      let velocityArrows = [];

      // Object to hold tooltip for instructions
      let tooltip = null;

      // ------------------------------------------------
      // Create bodies
      // ------------------------------------------------
      function createBodies() {
        // Clear existing bodies if any
        bodyMeshes.forEach(mesh => {
          if (mesh) scene.remove(mesh);
        });
        
        velocityArrows.forEach(arrow => {
          if (arrow) scene.remove(arrow);
        });
        
        bodyMeshes = [];
        velocityArrows = [];
        bodies = [];
        
        // Create tooltip for instructions if it doesn't exist
        if (!tooltip) {
          tooltip = document.createElement('div');
          tooltip.className = 'tooltip';
          container.appendChild(tooltip);
        }
        
      for (let i = 0; i < 3; i++) {
          // Calculate size based on mass (for visual representation)
          const size = getBodyRadius(masses[i]);
          
          // Create sphere for the body
          const bodyGeometry = new THREE.SphereGeometry(size, 32, 32);
        const bodyMaterial = new THREE.MeshPhongMaterial({
            color: BODY_COLORS[i],
            shininess: 30,
            emissive: new THREE.Color(BODY_COLORS[i]).multiplyScalar(0.2)
        });
          
        const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
        bodyMesh.position.copy(initialPositions[i]);
          bodyMesh.castShadow = true;
          bodyMesh.receiveShadow = true;
          bodyMesh.userData = { 
            bodyIndex: i,
            type: 'body' 
          };
          
        scene.add(bodyMesh);
        bodyMeshes.push(bodyMesh);

          // Create velocity arrow
          const arrowDirection = initialVelocities[i].clone().normalize();
          // Create arrows with sufficient length for visibility and interaction
          const baseLength = 3; // Increased from 2 for better interaction
          const velocityScale = 4; // Increased from 3 for better visibility
          let arrowLength = baseLength;
          if (initialVelocities[i].length() > 0) {
            arrowLength = baseLength + initialVelocities[i].length() * velocityScale;
          }
          
          const arrowHead = new THREE.Mesh(
            new THREE.ConeGeometry(0.5, 1.0, 8), // Increased size for easier interaction
            new THREE.MeshBasicMaterial({ color: BODY_COLORS[i] })
          );
          
          // Position the arrow head away from the body for better visibility
          const arrowHeadPosition = initialPositions[i].clone().add(
            arrowDirection.clone().multiplyScalar(arrowLength)
          );
          arrowHead.position.copy(arrowHeadPosition);
          
          // Orient the arrow head to point in the velocity direction
          if (arrowDirection.length() > 0) {
            // Calculate a point that continues in the direction from body to arrow
            const targetLook = arrowHead.position.clone().add(arrowDirection);
            arrowHead.lookAt(targetLook);
            arrowHead.rotateX(Math.PI / 2);
          }
          
          // Store arrowhead information for dragging and updating
          arrowHead.userData = {
            bodyIndex: i,
            type: 'velocityArrow',
            baseLength: baseLength,
            velocityScale: velocityScale
          };
          
          // Create arrow line
          const lineGeometry = new THREE.BufferGeometry().setFromPoints([
            initialPositions[i],
            arrowHeadPosition
          ]);
          const lineMaterial = new THREE.LineBasicMaterial({ color: BODY_COLORS[i] });
          const line = new THREE.Line(lineGeometry, lineMaterial);
          
          // Add to scene
          scene.add(arrowHead);
          scene.add(line);
          
          // Store arrow components
          velocityArrows.push({
            head: arrowHead,
            line: line,
            baseLength: baseLength,
            velocityScale: velocityScale
          });
          
          // Initialize body data
        bodies.push({
          position: initialPositions[i].clone(),
          velocity: initialVelocities[i].clone(),
          mass: masses[i],
            trail: []
          });
        }
        
        // Create drag controls
        setupDragControls();
        
        // Update the mass sliders to reflect current values
        updateMassSliders();
      }
      
      // Function to update mass sliders to match current values
      function updateMassSliders() {
        for (let i = 0; i < 3; i++) {
          const slider = document.getElementById(`body${i+1}MassSlider`);
          const valueDisplay = document.getElementById(`body${i+1}MassValue`);
          
          // Convert mass to slider value using the inverse mapping
          slider.value = massToSliderValue(masses[i]);
          valueDisplay.textContent = formatMassValue(masses[i]);
          
          // Also update the hidden input (useful for code that might still reference it)
          document.getElementById(`body${i+1}Mass`).value = masses[i];
        }
      }
      
      // Function to convert slider value (0-100) to actual mass (0.1-100)
      // This uses a quadratic/exponential mapping to give more precision at lower values
      function sliderValueToMass(sliderValue) {
        if (sliderValue <= 0) return 0.1; // Minimum mass
        
        // For values 0-50, map to range 0.1-10 (square function for more sensitivity at lower end)
        if (sliderValue <= 50) {
          return 0.1 + (9.9 * Math.pow(sliderValue / 50, 2));
        } 
        // For values 51-100, map to range 10-100 (linear mapping is fine for larger values)
        else {
          return 10 + ((sliderValue - 50) * 90 / 50);
        }
      }
      
      // Function to convert actual mass (0.1-100) to slider value (0-100)
      // This is the inverse of the above function
      function massToSliderValue(mass) {
        if (mass <= 0.1) return 0;
        
        // For masses 0.1-10, use inverse of quadratic function
        if (mass <= 10) {
          return Math.round(50 * Math.sqrt((mass - 0.1) / 9.9));
        } 
        // For masses 10-100, use inverse of linear function
        else {
          return Math.round(50 + ((mass - 10) * 50 / 90));
        }
      }

      // ------------------------------------------------
      // Setup drag controls for positioning bodies and velocity arrows
      // ------------------------------------------------
      let currentDragControls = null;

      function setupDragControls() {
        // First dispose of any existing controls
        if (currentDragControls) {
          currentDragControls.deactivate();
          currentDragControls.dispose();
          currentDragControls = null;
        }
        
        // Detect if we're on a touch device
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        
        // Get all draggable objects (bodies and arrow heads)
        const draggableObjects = [...bodyMeshes];
        
        // Add arrow heads
        velocityArrows.forEach(arrow => {
          draggableObjects.push(arrow.head);
        });
        
        // Create new drag controls
        currentDragControls = new DragControls(draggableObjects, camera, renderer.domElement);
        
        // Make drag controls less sensitive on touch devices
        if (isTouchDevice) {
          // Add larger touch areas for draggable objects
          draggableObjects.forEach(obj => {
            if (obj.userData.type === 'velocityArrow') {
              // Make velocity arrows easier to grab on touch devices
              const scale = 1.5; // 50% larger touch area
              obj.scale.set(scale, scale, scale);
            }
          });
        }
        
        currentDragControls.addEventListener('hoveron', function(event) {
          // Change cursor and show tooltip
          document.body.style.cursor = 'grab';
          
          // Show appropriate tooltip based on object type
          if (event.object.userData.type === 'body') {
            showTooltip('Drag to position the body', event);
          } else if (event.object.userData.type === 'velocityArrow') {
            showTooltip('Drag to set velocity direction and magnitude', event);
          }
        });
        
        currentDragControls.addEventListener('hoveroff', function() {
          // Reset cursor and hide tooltip
          document.body.style.cursor = 'auto';
          hideTooltip();
        });
        
        currentDragControls.addEventListener('dragstart', function(event) {
          // Temporarily disable orbit controls ONLY while actively dragging
          controls.enabled = false;
          
          // Change cursor style
          document.body.style.cursor = 'grabbing';
          
          // Hide tooltip during drag
          hideTooltip();
        });
        
        currentDragControls.addEventListener('drag', function(event) {
          const objectType = event.object.userData.type;
          const bodyIndex = event.object.userData.bodyIndex;
          
          if (objectType === 'body') {
            // Dragging a body
            const position = event.object.position;
            
            // Calculate distance from center
            const distance = Math.sqrt(position.x * position.x + position.z * position.z);
            
            // If outside boundary, constrain to boundary
            if (distance > BOUNDARY_RADIUS) {
              const angle = Math.atan2(position.z, position.x);
              position.x = BOUNDARY_RADIUS * Math.cos(angle);
              position.z = BOUNDARY_RADIUS * Math.sin(angle);
            }
            
            // Fix Y position to 0 (on the plane)
            position.y = 0;
            
            // Update the corresponding body position
            bodies[bodyIndex].position.copy(position);
            initialPositions[bodyIndex].copy(position);
            
            // Update velocity arrow position
            updateVelocityArrow(bodyIndex);
          } 
          else if (objectType === 'velocityArrow') {
            // Dragging a velocity arrow
            const arrowHead = event.object;
            const bodyPosition = bodyMeshes[bodyIndex].position;
            
            // Fix Y position to maintain horizontal plane
            arrowHead.position.y = 0;
            
            // Calculate new velocity based on the arrow position relative to the body
            const direction = new THREE.Vector3().subVectors(
              arrowHead.position,
              bodyPosition
            );
            
            // Get base length and scale from userData
            const baseLength = arrowHead.userData.baseLength;
            const velocityScale = arrowHead.userData.velocityScale;
            
            // Calculate actual direction length minus base length
            const totalLength = direction.length();
            let velocityMagnitude = 0;
            
            if (totalLength > baseLength) {
              velocityMagnitude = (totalLength - baseLength) / velocityScale;
            }
            
            // Normalize and scale to get new velocity
            if (direction.length() > 0) {
              direction.normalize();
              
              // Set new velocity
              const newVelocity = direction.multiplyScalar(velocityMagnitude);
              bodies[bodyIndex].velocity.copy(newVelocity);
              initialVelocities[bodyIndex].copy(newVelocity);
              
              // Orient arrow head
              if (direction.length() > 0) {
                // Calculate a point that continues in the direction from body to arrow
                const targetLook = arrowHead.position.clone().add(direction);
                arrowHead.lookAt(targetLook);
                arrowHead.rotateX(Math.PI / 2);
              }
              
              // Update velocity inputs
              updateVelocityInputs(bodyIndex, newVelocity);
            }
            
            // Update the line of the arrow
            updateVelocityArrowLine(bodyIndex);
          }
          
          // Update render
          renderScene();
        });
        
        currentDragControls.addEventListener('dragend', function(event) {
          // Always re-enable orbit controls
          controls.enabled = true;
          
          // Reset cursor
          document.body.style.cursor = 'auto';
          
          // Update positions and velocities for reset
          const objectType = event.object.userData.type;
          const bodyIndex = event.object.userData.bodyIndex;
          
          if (objectType === 'body') {
            initialPositions[bodyIndex].copy(event.object.position);
          } 
          else if (objectType === 'velocityArrow') {
            // Final update of velocity arrow and line
            updateVelocityArrow(bodyIndex);
          }
        });
      }
      
      // Function to update the velocity arrow based on current velocity
      function updateVelocityArrow(bodyIndex) {
        const arrow = velocityArrows[bodyIndex];
        const bodyPosition = bodyMeshes[bodyIndex].position;
        const velocity = bodies[bodyIndex].velocity;
        
        // Calculate arrow direction and length
        let arrowDirection;
        if (velocity.length() > 0) {
          arrowDirection = velocity.clone().normalize();
        } else {
          // Default direction if velocity is zero
          arrowDirection = new THREE.Vector3(1, 0, 0);
        }
        
        // Calculate length based on velocity magnitude
        const baseLength = arrow.baseLength;
        const velocityScale = arrow.velocityScale;
        const arrowLength = baseLength + velocity.length() * velocityScale;
        
        // Position arrow head
        const arrowHeadPosition = bodyPosition.clone().add(
          arrowDirection.clone().multiplyScalar(arrowLength)
        );
        arrow.head.position.copy(arrowHeadPosition);
        
        // Orient arrow head
        if (velocity.length() > 0) {
          // Calculate a point that continues in the direction from body to arrow
          const targetLook = arrowHeadPosition.clone().add(arrowDirection);
          arrow.head.lookAt(targetLook);
          arrow.head.rotateX(Math.PI / 2);
        }
        
        // Update line
        updateVelocityArrowLine(bodyIndex);
      }
      
      // Function to update just the line part of the velocity arrow
      function updateVelocityArrowLine(bodyIndex) {
        const arrow = velocityArrows[bodyIndex];
        const bodyPosition = bodyMeshes[bodyIndex].position;
        const arrowHeadPosition = arrow.head.position;
        
        // Update line geometry
        const points = [bodyPosition, arrowHeadPosition];
        arrow.line.geometry.dispose();
        arrow.line.geometry = new THREE.BufferGeometry().setFromPoints(points);
      }
      
      // Function to update velocity input fields
      function updateVelocityInputs(bodyIndex, velocity) {
        document.getElementById(`body${bodyIndex+1}VelocityX`).value = velocity.x.toFixed(2);
        document.getElementById(`body${bodyIndex+1}VelocityZ`).value = velocity.z.toFixed(2);
        
        // Also update the real-time velocity display
        updateRealTimeVelocityDisplay(bodyIndex);
      }
      
      // Show tooltip with instructions
      function showTooltip(text, event) {
        if (tooltip) {
          tooltip.textContent = text;
          tooltip.style.opacity = '1';
          
          // Position tooltip near the mouse/object
          const rect = renderer.domElement.getBoundingClientRect();
          
          // Use either mouse event or touch event coordinates
          let clientX, clientY;
          if (event.type && event.type.startsWith('touch')) {
            // Touch event - use the first touch point
            if (event.touches && event.touches.length > 0) {
              clientX = event.touches[0].clientX;
              clientY = event.touches[0].clientY;
            } else {
              // Fallback to object position for touch events without coordinates
              const mouseX = event.object.position.x;
              const mouseY = event.object.position.z;
              
              // Convert 3D position to screen position
              const vector = new THREE.Vector3(mouseX, 0, mouseY);
              vector.project(camera);
              
              clientX = (vector.x * 0.5 + 0.5) * rect.width + rect.left;
              clientY = -(vector.y * 0.5 - 0.5) * rect.height + rect.top;
            }
          } else {
            // Use object position for hover events
            const mouseX = event.object.position.x;
            const mouseY = event.object.position.z;
            
            // Convert 3D position to screen position
            const vector = new THREE.Vector3(mouseX, 0, mouseY);
            vector.project(camera);
            
            clientX = (vector.x * 0.5 + 0.5) * rect.width + rect.left;
            clientY = -(vector.y * 0.5 - 0.5) * rect.height + rect.top;
          }
          
          tooltip.style.left = clientX + 10 + 'px';
          tooltip.style.top = clientY + 10 + 'px';
        }
      }
      
      // Hide tooltip
      function hideTooltip() {
        if (tooltip) {
          tooltip.style.opacity = '0';
        }
      }

      // ------------------------------------------------
      // Trail management
      // ------------------------------------------------
      function createTrailSystem() {
        // Remove existing trails
        trailMeshes.forEach(mesh => {
          if (mesh) scene.remove(mesh);
        });
        
        trailMeshes = [null, null, null];
        
        for (let i = 0; i < 3; i++) {
          // Initialize trail with current position
          bodies[i].trail = [];
          bodies[i].trail.push(bodies[i].position.clone());
        }
        
        // Ensure trails are properly visualized if enabled
        if (showTrails) {
          updateTrails();
        }
      }

      function updateTrails() {
        for (let i = 0; i < 3; i++) {
          // Only update if showing trails
          if (!showTrails) {
            if (trailMeshes[i]) {
              scene.remove(trailMeshes[i]);
              trailMeshes[i] = null;
            }
            continue;
          }

          // Remove existing trail
          if (trailMeshes[i]) {
            scene.remove(trailMeshes[i]);
          }
          
          // Limit trail length
          if (bodies[i].trail.length > MAX_TRAIL_LENGTH) {
            bodies[i].trail = bodies[i].trail.slice(-MAX_TRAIL_LENGTH);
          }
          
          // Ensure there's at least one point in the trail (the current position)
          if (bodies[i].trail.length === 0) {
            bodies[i].trail.push(bodies[i].position.clone());
          }
          
          // For a stationary body with only one point, create artificial second point slightly offset
          // This ensures we can create a valid curve even for initially stationary bodies
          if (bodies[i].trail.length === 1) {
            // Add a very small offset to create a valid curve
            const offsetPoint = bodies[i].position.clone().add(new THREE.Vector3(0.01, 0, 0.01));
            bodies[i].trail.push(offsetPoint);
          }
          
          // Force Body 3 (index 2) to always show a trail even if it's not moving
          if (i === 2 && bodies[i].trail.length < 3) {
            // Create small circular path around current position as a workaround
            const angle = simulationTime * 0.1;
            const radius = 0.05;
            const x = bodies[i].position.x + Math.cos(angle) * radius;
            const z = bodies[i].position.z + Math.sin(angle) * radius;
            bodies[i].trail.push(new THREE.Vector3(x, bodies[i].position.y, z));
          }
          
          // Create new trail if we have enough points
          if (bodies[i].trail.length > 1) {
            // Use a tube geometry for more impressive trails
            const points = bodies[i].trail;
            
            // Calculate tube radius based on body mass
            const trailRadius = getTrailRadius(bodies[i].mass);
            
            // Create a smooth curve from points
            const curve = new THREE.CatmullRomCurve3(points);
            const tubeGeometry = new THREE.TubeGeometry(
              curve,
              Math.min(points.length * 2, 200), // Limit segments for performance
              trailRadius, // Scale tube radius based on mass
              8, // radial segments for roundness
              false // closed
            );
            
            // Create color gradient for trail
            const colors = [];
            const startColor = new THREE.Color(TRAIL_COLORS[i].start);
            const endColor = new THREE.Color(TRAIL_COLORS[i].end);
            
            const positionAttribute = tubeGeometry.getAttribute('position');
            const vertex = new THREE.Vector3();
            
            // For each vertex in the tube, assign a color
            for (let j = 0; j < positionAttribute.count; j++) {
              // Extract the vertex position
              vertex.fromBufferAttribute(positionAttribute, j);
              
              // Find the closest point on the curve to determine gradient position
              const t = curve.getUtoTmapping(j / positionAttribute.count);
              
              // Linear interpolation from start to end color, with bias toward start for a "fading tail" effect
              const ratio = Math.pow(t, 0.5); // Power for non-linear gradient
              const color = new THREE.Color().lerpColors(endColor, startColor, ratio);
              colors.push(color.r, color.g, color.b);
            }
            
            // Add the colors to the geometry
            tubeGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            // Create material with vertex colors
            const tubeMaterial = new THREE.MeshBasicMaterial({
              vertexColors: true,
              transparent: true,
              opacity: 0.8,
              side: THREE.DoubleSide
            });
            
            // Create the trail mesh
            const trailMesh = new THREE.Mesh(tubeGeometry, tubeMaterial);
            scene.add(trailMesh);
            trailMeshes[i] = trailMesh;
            
            // Add a subtle glow effect for more "shooting star" like appearance
            const glowMaterial = new THREE.MeshBasicMaterial({
              color: TRAIL_COLORS[i].start,
              transparent: true,
              opacity: 0.3,
              side: THREE.BackSide
            });
            
            const glowGeometry = new THREE.TubeGeometry(
              curve,
              Math.min(points.length * 2, 200),
              trailRadius * 1.6, // Scale glow effect proportionally
              8,
              false
            );
            
            const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
            trailMesh.add(glowMesh); // Add as a child for easy management
          }
        }
      }

      // ------------------------------------------------
      // Physics simulation
      // ------------------------------------------------
      // Function to calculate body radius based on mass
      function getBodyRadius(mass) {
        // More compressed scaling for masses up to 100
        // Using logarithmic scaling to avoid bodies getting too large
        if (mass <= 1) {
          return Math.max(0.5, Math.pow(mass, 1/3) * 0.45);
        } else {
          // Logarithmic scaling for masses > 1
          return 0.45 + 0.35 * Math.log10(mass);
        }
      }
      
      // Function to calculate trail radius based on body mass
      function getTrailRadius(mass) {
        // More compressed scaling for trail radius
        if (mass <= 1) {
          return Math.max(0.1, Math.pow(mass, 1/4) * 0.15);
        } else {
          // Logarithmic scaling for masses > 1
          return 0.15 + 0.08 * Math.log10(mass);
        }
      }
      
      // Function to calculate forces and update positions
      function updatePhysics(deltaTime) {
        // Update simulation time
        simulationTime += deltaTime;
        
        // Update the time display - make sure we're using the correct ID
        const timeDisplay = document.getElementById('simulation-time');
        if (timeDisplay) {
          timeDisplay.textContent = 'Time: ' + simulationTime.toFixed(2) + 's';
        }
        
        // Calculate forces and update velocities
        for (let i = 0; i < bodies.length; i++) {
          for (let j = i + 1; j < bodies.length; j++) {
            // Check for collision between bodies
            const body1 = bodies[i];
            const body2 = bodies[j];
            
            const distance = body1.position.distanceTo(body2.position);
            const body1Radius = getBodyRadius(body1.mass);
            const body2Radius = getBodyRadius(body2.mass);
            
            if (distance < (body1Radius + body2Radius)) {
              handleCollision(i, j);
              return;
            }
            
            // Calculate gravitational force
            const direction = new THREE.Vector3().subVectors(body2.position, body1.position);
            const distanceSquared = direction.lengthSq();
            
            if (distanceSquared > 0) {
              // Adjusted gravitational force calculation with scaling to prevent extreme forces
              // with very large masses
              const massProduct = body1.mass * body2.mass;
              let scaleFactor = 1.0;
              
              // Scale down force for very large mass products to prevent extreme accelerations
              if (massProduct > 100) {
                scaleFactor = 1.0 / Math.log10(massProduct / 10);
              }
              
              const forceMagnitude = G * massProduct / distanceSquared * scaleFactor;
              const force = direction.normalize().multiplyScalar(forceMagnitude);
              
              // Apply forces to bodies (F = ma, so a = F/m)
              const acc1 = force.clone().divideScalar(body1.mass);
              const acc2 = force.clone().negate().divideScalar(body2.mass);
              
              body1.velocity.add(acc1.multiplyScalar(deltaTime));
              body2.velocity.add(acc2.multiplyScalar(deltaTime));
            }
          }
          
          // Update real-time velocity display
          updateRealTimeVelocityDisplay(i);
        }
        
        // Update positions
        for (let i = 0; i < bodies.length; i++) {
          const body = bodies[i];
          
          // Calculate velocity magnitude before update (to detect changes from stationary)
          const prevVelocityMagnitude = body.velocity.length();
          
          // Update position based on velocity
          body.position.add(body.velocity.clone().multiplyScalar(deltaTime));
          
          // Check boundary only if Free Play mode is not active
          if (!freePlayMode) {
            const distanceFromCenter = Math.sqrt(
              body.position.x * body.position.x + 
              body.position.z * body.position.z
            );
            
            // Account for body size when checking boundary
            const bodyRadius = getBodyRadius(body.mass);
            if (distanceFromCenter + bodyRadius > BOUNDARY_RADIUS) {
              handleBoundaryViolation(i);
              return;
            }
          }
          
          // Update mesh position
          bodyMeshes[i].position.copy(body.position);
          
          // Always add the position to trail history - this allows us to show the full path
          // when trails are toggled on, even if they were off during part of the simulation
          body.trail.push(body.position.clone());
          
          // Special handling for Body 3 (index 2) if it just started moving
          if (i === 2 && prevVelocityMagnitude < 0.0001 && body.velocity.length() > 0.0001) {
            // Clear previous trail if it was artificial and create a fresh one
            body.trail = [];
            body.trail.push(body.position.clone());
            
            // Handle special case for initially stationary Body 3
            if (showTrails) {
              updateTrails();
            }
          }
        }
        
        // Always force a trail update for Body 3 in the first 10 seconds of simulation
        // This ensures it has a visible trail even when initially stationary
        if (simulationTime < 10 && bodies[2].velocity.length() <= 0.001) {
          // Add a slightly offset point for Body 3 to create a visible trail
          const body = bodies[2];
          const angle = simulationTime;
          const radius = 0.05;
          const x = body.position.x + Math.cos(angle) * radius;
          const z = body.position.z + Math.sin(angle) * radius;
          
          // Only add points occasionally
          if (Math.random() < 0.2) {
            body.trail.push(new THREE.Vector3(x, body.position.y, z));
          }
        }
        
        // Update trails if they're visible
        if (showTrails) {
          updateTrails();
        }
      }
      
      // Handle collision between bodies
      function handleCollision(index1, index2) {
        if (collisionOccurred) return;
        
        collisionOccurred = true;
        
        // Show reset button row
        document.getElementById('resetButtonRow').style.display = 'flex';
        document.getElementById('resetLastButton').style.display = 'inline-block';
        document.getElementById('resetDefaultButton').style.display = 'inline-block';
        
        // Force trails on when collision occurs
        showTrails = true;
        document.getElementById('toggleTrailsButton').textContent = 'Hide Trails';
        
        // Update trails to make them visible
        updateTrails();
        
        isAnimating = false;
        
        // Visual effect for collision
        const collisionPoint = new THREE.Vector3().addVectors(
          bodies[index1].position,
          bodies[index2].position
        ).multiplyScalar(0.5);
        
        createExplosionEffect(collisionPoint);
        
        // Update UI state
        document.getElementById('startButton').disabled = true;
        document.getElementById('stopButton').disabled = true;
        updateStatusMessage('Collision detected!');
      }
      
      // Handle body going outside boundary
      function handleBoundaryViolation(index) {
        if (collisionOccurred) return;
        
        collisionOccurred = true;
        
        // Show reset button row
        document.getElementById('resetButtonRow').style.display = 'flex';
        document.getElementById('resetLastButton').style.display = 'inline-block';
        document.getElementById('resetDefaultButton').style.display = 'inline-block';
        
        // Force trails on when boundary violation occurs
        showTrails = true;
        document.getElementById('toggleTrailsButton').textContent = 'Hide Trails';
        
        // Update trails to make them visible
        updateTrails();
        
        isAnimating = false;
        
        // Visual effect for boundary violation
        createBoundaryEffect(bodies[index].position);
        
        // Update UI state
        document.getElementById('startButton').disabled = true;
        document.getElementById('stopButton').disabled = true;
        updateStatusMessage('Boundary violation!');
      }
      
      // Create explosion effect at collision
      function createExplosionEffect(position) {
        const particleCount = 100;
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        
        for (let i = 0; i < particleCount; i++) {
          // Random positions in a sphere
          const x = (Math.random() - 0.5) * 2;
          const y = (Math.random() - 0.5) * 2;
          const z = (Math.random() - 0.5) * 2;
          positions.push(x, y, z);
        }
        
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        
        const material = new THREE.PointsMaterial({
          color: 0xffff00,
          size: 0.2,
          transparent: true
        });
        
        const particles = new THREE.Points(geometry, material);
        particles.position.copy(position);
        scene.add(particles);
        
        // Animation to expand and fade
        const expandAnimation = () => {
          const positionAttr = particles.geometry.attributes.position;
          
          for (let i = 0; i < positionAttr.count; i++) {
            const x = positionAttr.getX(i);
            const y = positionAttr.getY(i);
            const z = positionAttr.getZ(i);
            
            positionAttr.setX(i, x * 1.05);
            positionAttr.setY(i, y * 1.05);
            positionAttr.setZ(i, z * 1.05);
          }
          
          positionAttr.needsUpdate = true;
          material.opacity -= 0.02;
          
          if (material.opacity > 0) {
            requestAnimationFrame(expandAnimation);
          } else {
            scene.remove(particles);
          }
          
          renderer.render(scene, camera);
        };
        
        expandAnimation();
      }
      
      // Create effect for boundary violation
      function createBoundaryEffect(position) {
        const ringGeometry = new THREE.RingGeometry(0.5, 1, 32);
        const ringMaterial = new THREE.MeshBasicMaterial({
          color: 0xff0000,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 1
        });
        
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.position.copy(position);
        ring.lookAt(camera.position); // Face camera
        scene.add(ring);
        
        // Animation to expand and fade
        const expandAnimation = () => {
          ring.scale.x *= 1.05;
          ring.scale.y *= 1.05;
          ring.scale.z *= 1.05;
          ringMaterial.opacity -= 0.02;
          
          if (ringMaterial.opacity > 0) {
            requestAnimationFrame(expandAnimation);
          } else {
            scene.remove(ring);
          }
          
          renderer.render(scene, camera);
        };
        
        expandAnimation();
      }

      // ------------------------------------------------
      // Animation loop
      // ------------------------------------------------
      // Modified animate function to use enhanced cinematic mode
      function animate() {
        animationId = requestAnimationFrame(animate);
        
        // Continue cinematic camera cuts even when not animating
        if (cinematicMode) {
          applyCinematicCameraMovement();
        }
        
        if (isAnimating && !isPaused) {
          // Update physics (with constant time step for stability)
          updatePhysics(simulationSpeed);
          
          // Always update velocity displays
          for (let i = 0; i < bodies.length; i++) {
            updateRealTimeVelocityDisplay(i);
          }
          
          // Update camera if following but not in cinematic mode
          if (isFollowing && !cinematicMode) {
            // Determine which body to follow
            let bodyToFollow = bodies[followingBodyIndex || 0];
            const offset = new THREE.Vector3(0, 15, 25);
            camera.position.copy(bodyToFollow.position).add(offset);
            camera.lookAt(bodyToFollow.position);
            controls.target.copy(bodyToFollow.position);
          }
        }
        
        // Always update controls for smooth camera interaction
        controls.update();
        
        // Render scene
        renderer.render(scene, camera);
      }

      // ------------------------------------------------
      // Core simulation functions
      // ------------------------------------------------
      
      // Handle simulation state changes: start, stop, pause, reset
      function startSimulation() {
        if (collisionOccurred) {
          // Don't automatically reset, just show the reset buttons
          document.getElementById('resetButtonRow').style.display = 'flex';
          return; // Return early if collision occurred
        }
        
        if (isAnimating) return;
        
        // Starting the simulation
        isAnimating = true;
        isPaused = false;
        collisionOccurred = false;
        simulationTime = 0; // Reset simulation time
        
        // Disable start button, enable stop button
        document.getElementById('startButton').disabled = true;
        document.getElementById('stopButton').disabled = false;
        
        updateStatusMessage('Running');
        
        // Hide reset button row when simulation starts
        document.getElementById('resetButtonRow').style.display = 'none';
        
        // Hide velocity arrows when simulation starts
        for (let i = 0; i < velocityArrows.length; i++) {
          velocityArrows[i].head.visible = false;
          velocityArrows[i].line.visible = false;
        }
        
        // Save the current positions, velocities, and masses for reset
        for (let i = 0; i < 3; i++) {
          initialPositions[i].copy(bodies[i].position);
          initialVelocities[i].copy(bodies[i].velocity);
          masses[i] = bodies[i].mass; // Save current mass values
          
          // Clear any existing trail points and add initial position
          bodies[i].trail = [];
          bodies[i].trail.push(bodies[i].position.clone());
        }
        
        // Ensure trails system is ready
        updateTrails();
      }

      function stopSimulation() {
        // Stop animation
        isAnimating = false;
        isPaused = false;
        simulationTime = 0;
        
        // Enable start button, disable stop button
        document.getElementById('startButton').disabled = false;
        document.getElementById('stopButton').disabled = true;
        
        // Show reset options
        document.getElementById('resetButtonRow').style.display = 'flex';
        document.getElementById('resetLastButton').style.display = 'flex';
        document.getElementById('resetDefaultButton').style.display = 'flex';
        
        // Reset pause button text
        document.getElementById('pauseButton').textContent = 'Pause';
        
        updateStatusMessage('Stopped');
        
        // Show velocity arrows when simulation stops
        for (let i = 0; i < velocityArrows.length; i++) {
          velocityArrows[i].head.visible = true;
          velocityArrows[i].line.visible = true;
        }
      }
      
      function pauseSimulation() {
        if (!isAnimating) return;
        
        isPaused = !isPaused;
        
        // Update button text based on state
        document.getElementById('pauseButton').textContent = isPaused ? 'Play' : 'Pause';
        
        updateStatusMessage(isPaused ? 'Paused' : 'Running');
      }
      
      // Function to reset simulation to previous positions
      function resetSimulation() {
        // Stop animation
        isAnimating = false;
        isPaused = false;
        simulationTime = 0;
        collisionOccurred = false;
        
        // Enable start button, disable stop button
        document.getElementById('startButton').disabled = false;
        document.getElementById('stopButton').disabled = true;
        
        // Reset pause button text
        document.getElementById('pauseButton').textContent = 'Pause';
        
        // Note: We no longer reset Borderless mode when using Reset (Previous)
        // This allows the user to maintain their borderless mode preference
        
        updateStatusMessage('Ready');
        
        // Hide reset buttons
        document.getElementById('resetButtonRow').style.display = 'none';
        document.getElementById('resetLastButton').style.display = 'none';
        document.getElementById('resetDefaultButton').style.display = 'none';
        
        // Reset bodies to initial state
        for (let i = 0; i < bodies.length; i++) {
          bodies[i].position.copy(initialPositions[i]);
          bodies[i].velocity.copy(initialVelocities[i]);
          bodies[i].mass = masses[i]; // Restore mass from saved values
          
          // If not in free play mode, ensure bodies are within the boundary
          if (!freePlayMode) {
            const distanceFromCenter = Math.sqrt(
              initialPositions[i].x * initialPositions[i].x + 
              initialPositions[i].z * initialPositions[i].z
            );
            
            const bodyRadius = getBodyRadius(masses[i]);
            
            // If body would be outside boundary, move it inside
            if (distanceFromCenter + bodyRadius > BOUNDARY_RADIUS) {
              // Calculate angle to maintain direction but reduce distance
              const angle = Math.atan2(initialPositions[i].z, initialPositions[i].x);
              const newDistance = BOUNDARY_RADIUS - bodyRadius - 0.1; // Small buffer
              
              // Set new position within boundary
              initialPositions[i].x = newDistance * Math.cos(angle);
              initialPositions[i].z = newDistance * Math.sin(angle);
              bodies[i].position.copy(initialPositions[i]);
            }
          }
          
          bodyMeshes[i].position.copy(bodies[i].position);
          
          // Reset trail
          bodies[i].trail = [];
          // Initialize with starting position
          bodies[i].trail.push(bodies[i].position.clone());
          
          // Update real-time velocity displays
          updateRealTimeVelocityDisplay(i);
        }
        
        // Update trails to ensure they're visible if enabled
        updateTrails();
        
        // Update mass sliders to reflect restored values
        updateMassSliders();
        
        // Update visibility of boundary elements based on current mode
        // This ensures the visual state matches the freePlayMode setting
        boundaryPlane.visible = !freePlayMode;
        window.boundaryGrid.visible = !freePlayMode;
        window.boundaryRing.visible = !freePlayMode;
        window.largeGrid.visible = freePlayMode;
        window.largePlane.visible = freePlayMode;
        
        // Update the free play button visual state
        const freePlayButton = document.getElementById('freePlayButton');
        if (freePlayMode) {
          freePlayButton.classList.add('active');
          freePlayButton.textContent = 'Toggle Border';
        } else {
          freePlayButton.classList.remove('active');
          freePlayButton.textContent = 'Toggle Borderless';
        }
        
        // Update velocity arrows after body meshes are updated
        for (let i = 0; i < 3; i++) {
          updateVelocityArrow(i);
          velocityArrows[i].head.visible = true;
          velocityArrows[i].line.visible = true;
        }
        
        // Reset trail system
        createTrailSystem();
        
        // Enable orbit controls
        controls.enabled = true;
        
        // Reset to angled view
        setAngledView();
        
        // Reinitialize drag controls to ensure they're fresh
        setupDragControls();
        
        // Render the reset scene
        renderScene();
      }
      
      // Update status message in a consistent way
      function updateStatusMessage(message) {
        // Status messages are now removed
        console.log("Status: " + message);
      }
      
      // Camera control functions
      function setCamera(position, target) {
        isFollowing = false;
        
        // Don't disable cinematic mode when changing camera views
        
        camera.position.copy(position);
        camera.lookAt(target || new THREE.Vector3(0, 0, 0));
        
        controls.target.copy(target || new THREE.Vector3(0, 0, 0));
        controls.update();
        
        renderScene();
      }
      
      function followBody(bodyIndex) {
        isFollowing = true;
        followingBodyIndex = bodyIndex;
        
        // Don't disable cinematic mode when following a body
        
        const offset = new THREE.Vector3(0, 15, 25);
        camera.position.copy(bodies[bodyIndex].position).add(offset);
        camera.lookAt(bodies[bodyIndex].position);
        
        controls.target.copy(bodies[bodyIndex].position);
        controls.update();
        
        renderScene();
      }
      
      // ------------------------------------------------
      // Event handlers for UI controls
      // ------------------------------------------------
      
      // Set up all event listeners
      function setupEventListeners() {
        // Control panel toggling
        document.getElementById('controlHeader').addEventListener('click', function() {
          const content = document.getElementById('controlContent');
          const toggleButton = document.getElementById('toggleControlsButton');
          content.classList.toggle('collapsed');
          toggleButton.textContent = content.classList.contains('collapsed') ? '▲' : '▼';
        });
        
        // Speed controls toggling
        document.getElementById('speedHeader').addEventListener('click', function() {
          const speedControls = document.getElementById('speedControls');
          const toggleButton = document.getElementById('toggleSpeedButton');
          speedControls.classList.toggle('collapsed');
          toggleButton.textContent = speedControls.classList.contains('collapsed') ? '▲' : '▼';
        });
        
        // Camera controls toggling
        document.getElementById('cameraHeader').addEventListener('click', function() {
          const cameraControls = document.getElementById('camera-controls');
          const toggleButton = document.getElementById('toggleCameraButton');
          cameraControls.classList.toggle('collapsed');
          toggleButton.textContent = cameraControls.classList.contains('collapsed') ? '▲' : '▼';
        });
        
        // Mass controls toggling
        document.getElementById('massHeader').addEventListener('click', function() {
          const massControls = document.getElementById('mass-controls');
          const toggleButton = document.getElementById('toggleMassButton');
          massControls.classList.toggle('collapsed');
          toggleButton.textContent = massControls.classList.contains('collapsed') ? '▲' : '▼';
        });
        
        // UI toggle functionality
        document.getElementById('ui-toggle').addEventListener('click', function() {
          document.body.classList.toggle('ui-hidden');
          this.textContent = document.body.classList.contains('ui-hidden') ? 'Show UI' : 'Hide UI';
        });
        
        // Simulation controls
        document.getElementById('startButton').addEventListener('click', startSimulation);
        document.getElementById('stopButton').addEventListener('click', stopSimulation);
        document.getElementById('resetLastButton').addEventListener('click', resetSimulation);
        document.getElementById('resetDefaultButton').addEventListener('click', resetDefault);
        document.getElementById('pauseButton').addEventListener('click', pauseSimulation);
        
        // Trail toggle
        document.getElementById('toggleTrailsButton').addEventListener('click', function() {
          showTrails = !showTrails;
          
          document.getElementById('toggleTrailsButton').textContent = 
            showTrails ? 'Hide Trails' : 'Show Trails';
          
          // If showing trails, update them to show the full path
          if (showTrails) {
            updateTrails();
          } else {
            // Hide trails by removing them from scene
          for (let i = 0; i < 3; i++) {
              if (trailMeshes[i]) {
                scene.remove(trailMeshes[i]);
                trailMeshes[i] = null;
              }
            }
          }
          
          renderScene();
        });
        
        // Camera views
        document.getElementById('topViewButton').addEventListener('click', function() {
          setCamera(new THREE.Vector3(0, 75, 0.1));
        });
        
        document.getElementById('sideViewButton').addEventListener('click', function() {
          // Add 3-degree angle to side view (converting to radians)
          const angleRadians = 3 * (Math.PI / 180);
          const sideX = 75;
          const sideY = sideX * Math.tan(angleRadians); // Calculate Y offset for 3-degree angle
          setCamera(new THREE.Vector3(sideX, sideY, 0));
        });
        
        document.getElementById('angledViewButton').addEventListener('click', function() {
          setAngledView();
        });
        
        document.getElementById('wideViewButton').addEventListener('click', function() {
          setCamera(new THREE.Vector3(100, 100, 100));
        });
        
        document.getElementById('superWideViewButton').addEventListener('click', function() {
          setCamera(new THREE.Vector3(150, 150, 150));
        });
        
        // Follow body controls
        document.getElementById('followBody1Button').addEventListener('click', function() {
          followBody(0);
        });
        
        document.getElementById('followBody2Button').addEventListener('click', function() {
          followBody(1);
        });
        
        document.getElementById('followBody3Button').addEventListener('click', function() {
          followBody(2);
        });
        
        // Cinematic mode toggle
        document.getElementById('cinematicButton').addEventListener('click', function() {
          cinematicMode = !cinematicMode;
          this.classList.toggle('active');
          
          if (cinematicMode) {
            updateStatusMessage('Cinematic Mode Enabled');
            // Initialize the last cut time to now
            lastCameraCutTime = Date.now();
            // Set the current camera view based on current state
            if (isFollowing) {
              currentCameraView = `follow${followingBodyIndex + 1}`;
            } else {
              // Try to detect which view we're in based on camera position
              const pos = camera.position;
              if (Math.abs(pos.x) < 1 && pos.y > 70) {
                currentCameraView = 'top';
              } else if (pos.x > 70 && Math.abs(pos.y) < 1) {
                currentCameraView = 'side';
              } else if (pos.x > 90 && pos.y > 90) {
                currentCameraView = 'wide';
              } else {
                currentCameraView = 'angled';
              }
            }
          } else {
            updateStatusMessage('Cinematic Mode Disabled');
          }
        });
        
        // Borderless mode toggle
        document.getElementById('freePlayButton').addEventListener('click', function() {
          freePlayMode = !freePlayMode;
          
          // If trying to switch from Borderless to Normal mode, check if any body is outside the boundary
          if (!freePlayMode) {
            let bodyOutside = false;
            
            for (let i = 0; i < bodies.length; i++) {
              const body = bodies[i];
              const distanceFromCenter = Math.sqrt(
                body.position.x * body.position.x + 
                body.position.z * body.position.z
              );
              const bodyRadius = getBodyRadius(body.mass);
              
              // If a body is outside the boundary
              if (distanceFromCenter + bodyRadius > BOUNDARY_RADIUS) {
                bodyOutside = true;
                break;
              }
            }
            
            if (bodyOutside) {
              // Flash the boundary to indicate the violation
              const originalColor = boundaryPlane.material.color.clone();
              boundaryPlane.material.color.set(0xff0000);
              
              // Show a confirmation dialog
              const switchToNormalMode = confirm("Warning: One or more bodies are outside the boundary!\n\nClick 'OK' to switch to Border Mode and end the simulation, or 'Cancel' to stay in Borderless Mode.");
              
              // If user chooses to switch to Normal Mode
              if (switchToNormalMode) {
                // User chose to continue to Normal Mode despite warning
                setTimeout(() => {
                  boundaryPlane.material.color.copy(originalColor);
                }, 500);
              } else {
                // User chose to stay in Borderless Mode
                freePlayMode = true; // Revert the toggle
                
                // Reset boundary color after short delay
                setTimeout(() => {
                  boundaryPlane.material.color.copy(originalColor);
                }, 500);
                
                // Skip the rest of the function
                this.classList.add('active'); // Make sure button stays active
                this.textContent = 'Toggle Border'; // Keep button text correct
                return;
              }
            }
          }
          
          // Continue with toggling if we didn't return early
          this.classList.toggle('active');
          
          // Update label on button
          this.textContent = freePlayMode ? 'Toggle Border' : 'Toggle Borderless';
          
          // Update boundary visualization
          boundaryPlane.visible = !freePlayMode;
          window.boundaryGrid.visible = !freePlayMode;
          window.boundaryRing.visible = !freePlayMode;
          window.largeGrid.visible = freePlayMode;
          window.largePlane.visible = freePlayMode;
          
          updateStatusMessage(freePlayMode ? 'Borderless Mode' : 'Normal Mode');
          renderScene();
        });
        
        // Speed controls
        document.getElementById('slowSpeedButton').addEventListener('click', function() {
          simulationSpeed = 0.18; // Increased by 20% from 0.15
          updateStatusMessage('Slow Speed');
          updateSpeedButtonStyles(this);
          updateSmallSpeedButtonStyles('slowSpeedButton-small');
        });
        
        document.getElementById('normalSpeedButton').addEventListener('click', function() {
          simulationSpeed = 0.3; // Increased by 20% from 0.25
          updateStatusMessage('Normal Speed');
          updateSpeedButtonStyles(this);
          updateSmallSpeedButtonStyles('normalSpeedButton-small');
        });
        
        document.getElementById('fastSpeedButton').addEventListener('click', function() {
          simulationSpeed = 0.72; // Increased by 20% from 0.6
          updateStatusMessage('Fast Speed');
          updateSpeedButtonStyles(this);
          updateSmallSpeedButtonStyles('fastSpeedButton-small');
        });
        
        document.getElementById('veryFastSpeedButton').addEventListener('click', function() {
          simulationSpeed = 1.44; // Increased by 20% from 1.2
          updateStatusMessage('Very Fast Speed');
          updateSpeedButtonStyles(this);
          updateSmallSpeedButtonStyles('veryFastSpeedButton-small');
        });
        
        document.getElementById('superFastSpeedButton').addEventListener('click', function() {
          simulationSpeed = 2.4; // Increased by 20% from 2.0
          updateStatusMessage('Super Fast Speed');
          updateSpeedButtonStyles(this);
          updateSmallSpeedButtonStyles('superFastSpeedButton-small');
        });
        
        // Small speed buttons in main control panel
        document.getElementById('slowSpeedButton-small').addEventListener('click', function() {
          simulationSpeed = 0.18;
          updateStatusMessage('Slow Speed');
          updateSmallSpeedButtonStyles(this.id);
          updateSpeedButtonStyles(document.getElementById('slowSpeedButton'));
        });
        
        document.getElementById('normalSpeedButton-small').addEventListener('click', function() {
          simulationSpeed = 0.3;
          updateStatusMessage('Normal Speed');
          updateSmallSpeedButtonStyles(this.id);
          updateSpeedButtonStyles(document.getElementById('normalSpeedButton'));
        });
        
        document.getElementById('fastSpeedButton-small').addEventListener('click', function() {
          simulationSpeed = 0.72;
          updateStatusMessage('Fast Speed');
          updateSmallSpeedButtonStyles(this.id);
          updateSpeedButtonStyles(document.getElementById('fastSpeedButton'));
        });
        
        document.getElementById('veryFastSpeedButton-small').addEventListener('click', function() {
          simulationSpeed = 1.44;
          updateStatusMessage('Very Fast Speed');
          updateSmallSpeedButtonStyles(this.id);
          updateSpeedButtonStyles(document.getElementById('veryFastSpeedButton'));
        });
        
        document.getElementById('superFastSpeedButton-small').addEventListener('click', function() {
          simulationSpeed = 2.4;
          updateStatusMessage('Super Fast Speed');
          updateSmallSpeedButtonStyles(this.id);
          updateSpeedButtonStyles(document.getElementById('superFastSpeedButton'));
        });
        
        // Update the speed button styles to show which one is active
        function updateSpeedButtonStyles(activeButton) {
          document.querySelectorAll('.speed-button').forEach(button => {
            button.classList.remove('speed-active');
          });
          activeButton.classList.add('speed-active');
        }
        
        // Update small speed button styles
        function updateSmallSpeedButtonStyles(activeButtonId) {
          document.querySelectorAll('.speed-button-small').forEach(button => {
            button.classList.remove('speed-active');
          });
          document.getElementById(activeButtonId).classList.add('speed-active');
        }
        
        // Window resize handler
        window.addEventListener('resize', handleWindowResize);
        
        // Orientation change handler (for tablets/mobile)
        window.addEventListener('orientationchange', function() {
          setTimeout(() => {
            // Delay execution to allow the browser to complete the orientation change
            handleWindowResize();
            
            // Additional iPad-specific adjustments
            const isLandscape = window.innerWidth > window.innerHeight;
            
            // Adjust UI elements based on orientation
            if (isLandscape) {
              // Landscape orientation - spread controls horizontally
              if (document.getElementById('mass-controls')) {
                document.getElementById('mass-controls').style.maxHeight = '80vh';
              }
            } else {
              // Portrait orientation - stack controls vertically
              if (document.getElementById('mass-controls')) {
                document.getElementById('mass-controls').style.maxHeight = '40vh';
              }
            }
            
            // Force a render to update the scene
            renderScene();
          }, 300); // Short delay to ensure screen dimensions have updated
        });
      }
      
      // Handle window resize
      function handleWindowResize() {
        // Determine new size based on window dimensions and 16:9 aspect ratio
        let newWidth, newHeight;
        if (window.innerWidth / window.innerHeight > aspectRatio) {
          // Window is wider than 16:9
          newHeight = window.innerHeight;
          newWidth = newHeight * aspectRatio;
        } else {
          // Window is taller than 16:9
          newWidth = window.innerWidth;
          newHeight = newWidth / aspectRatio;
        }
        
        // Update camera
        camera.aspect = aspectRatio;
        camera.updateProjectionMatrix();
        
        // Update renderer
        renderer.setSize(newWidth, newHeight);
        
        // Render the scene
        renderScene();
      }
      
      // Initial setup and scene initialization
      function initScene() {
        // Set up default configuration
        // Central star with two orbiting bodies
        initialPositions[0].set(-5, 0, 0);     // Left body
        initialPositions[1].set(5, 0, 0);      // Right body
        initialPositions[2].set(0, 0, 0);      // Center body
        
        initialVelocities[0].set(0, 0, 0.42);  // Left body moving up
        initialVelocities[1].set(0, 0, -0.42); // Right body moving down
        initialVelocities[2].set(0, 0, 0);     // Center body stationary
        
        masses[0] = 1.0;  // Left body mass
        masses[1] = 1.0;  // Right body mass
        masses[2] = 1.5;  // Center body mass (heavier)
        
        // Create bodies
        createBodies();
        
        // Set up real-time parameter updates
        setupRealTimeUpdates();
        
        // Set up event listeners
        setupEventListeners();
        
        // Initialize real-time velocity displays
        initializeRealTimeVelocity();
        
        // Set initial camera to angled view for best initial appearance
        setAngledView();
        
        // Ensure camera is looking at origin
        camera.lookAt(0, 0, 0);
        controls.target.set(0, 0, 0);
        controls.update();
        
        // Reset simulation state
        resetSimulation();
        
        // Force an initial render to ensure everything is visible
        renderScene();
        
        // Initialize body1MassSlider to match the mass
        document.getElementById('body1MassSlider').value = massToSliderValue(masses[0]);
        document.getElementById('body2MassSlider').value = massToSliderValue(masses[1]);
        document.getElementById('body3MassSlider').value = massToSliderValue(masses[2]);
        
        // Set initial button states
        document.getElementById('startButton').disabled = false;
        document.getElementById('stopButton').disabled = true;
      }
      
      // Start the initialization
      initScene();

      // Start the animation loop to keep controls responsive
      animate();

      // Helper function for rendering
      function renderScene() {
        renderer.render(scene, camera);
      }
      
      // Real-time update of parameters without needing to click "Apply"
      function setupRealTimeUpdates() {
        // Mass sliders
        const body1Slider = document.getElementById('body1MassSlider');
        const body2Slider = document.getElementById('body2MassSlider');
        const body3Slider = document.getElementById('body3MassSlider');
        
        // Function to handle both mouse and touch events for sliders
        function setupSliderEvents(slider, bodyIndex, tooltipText) {
          // Mouse events
          slider.addEventListener('mouseover', function(event) {
            showSliderTooltip(tooltipText, event, this);
          });
          
          slider.addEventListener('mouseout', function() {
            if (!this.isActive) {
              hideTooltip();
            }
          });
          
          slider.addEventListener('mousedown', function() {
            this.isActive = true;
          });
          
          slider.addEventListener('mouseup', function() {
            this.isActive = false;
            if (!this.matches(':hover')) {
              hideTooltip();
            }
          });
          
          slider.addEventListener('mousemove', function(event) {
            if (this.matches(':hover')) {
              showSliderTooltip(tooltipText, event, this);
            }
          });
          
          // Touch events
          slider.addEventListener('touchstart', function(event) {
            this.isActive = true;
            showSliderTooltip(tooltipText, event, this);
            event.preventDefault(); // Prevent scrolling while touching slider
          });
          
          slider.addEventListener('touchend', function() {
            this.isActive = false;
            hideTooltip();
          });
          
          slider.addEventListener('touchmove', function(event) {
            showSliderTooltip(tooltipText, event, this);
            event.preventDefault(); // Prevent scrolling while adjusting slider
          });
          
          // Input event for value changes
          slider.addEventListener('input', function() {
            const sliderValue = parseInt(this.value);
            const massValue = sliderValueToMass(sliderValue);
            document.getElementById(`body${bodyIndex+1}MassValue`).textContent = formatMassValue(massValue);
            document.getElementById(`body${bodyIndex+1}Mass`).value = massValue;
            updateBodyMass(bodyIndex, massValue);
          });
        }
        
        // Setup events for each slider
        setupSliderEvents(body1Slider, 0, 'Adjust mass of Body 1');
        setupSliderEvents(body2Slider, 1, 'Adjust mass of Body 2');
        setupSliderEvents(body3Slider, 2, 'Adjust mass of Body 3');
        
        // Velocity X input
        const velocityXInput = document.getElementById('body3VelocityX');
        setupInputEvents(velocityXInput, 'Adjust X velocity of Body 3', function(value) {
          document.getElementById('body3VelocityX').value = value;
          updateBodyVelocity(2, 'x', value);
        });
        
        // Velocity Z input
        const velocityZInput = document.getElementById('body3VelocityZ');
        setupInputEvents(velocityZInput, 'Adjust Y velocity of Body 3', function(value) {
          document.getElementById('body3VelocityZ').value = value;
          updateBodyVelocity(2, 'z', value);
        });
      }
      
      // Helper function to set up events for input elements
      function setupInputEvents(inputElement, tooltipText, changeCallback) {
        // Mouse events
        inputElement.addEventListener('mouseover', function(event) {
          showSliderTooltip(tooltipText, event, this);
        });
        
        inputElement.addEventListener('mouseout', function() {
          if (!this.isActive) {
            hideTooltip();
          }
        });
        
        inputElement.addEventListener('mousedown', function() {
          this.isActive = true;
        });
        
        inputElement.addEventListener('mouseup', function() {
          this.isActive = false;
          if (!this.matches(':hover')) {
            hideTooltip();
          }
        });
        
        inputElement.addEventListener('mousemove', function(event) {
          if (this.matches(':hover')) {
            showSliderTooltip(tooltipText, event, this);
          }
        });
        
        // Touch events
        inputElement.addEventListener('touchstart', function(event) {
          this.isActive = true;
          showSliderTooltip(tooltipText, event, this);
        });
        
        inputElement.addEventListener('touchend', function() {
          this.isActive = false;
          hideTooltip();
        });
        
        // Input event
        inputElement.addEventListener('input', function() {
          const value = parseFloat(this.value);
          changeCallback(value);
        });
      }
      
      // Function to show tooltip for sliders (positioned to the left)
      function showSliderTooltip(text, event, sliderElement) {
        if (tooltip) {
          tooltip.textContent = text;
          tooltip.style.opacity = '1';
          
          // First render the tooltip without position to calculate its dimensions
          tooltip.style.left = '-1000px';
          tooltip.style.top = '-1000px';
          
          // Use a small timeout to ensure the tooltip dimensions are calculated
          setTimeout(() => {
            // Get slider's position
            const rect = sliderElement.getBoundingClientRect();
            
            // Position tooltip to the left of the slider
            tooltip.style.left = (rect.left - tooltip.offsetWidth - 10) + 'px';
            tooltip.style.top = (rect.top + rect.height/2 - tooltip.offsetHeight/2) + 'px';
          }, 10);
        }
      }
      
      // Helper function to update mass
      function updateBodyMass(bodyIndex, massValue) {
        // Update mass value
        masses[bodyIndex] = massValue;
        bodies[bodyIndex].mass = massValue;
        
        // Update visual size to match mass
        const size = getBodyRadius(massValue);
        
        // Remove old mesh
        scene.remove(bodyMeshes[bodyIndex]);
        
        // Create new mesh with updated size
        const bodyGeometry = new THREE.SphereGeometry(size, 32, 32);
        const bodyMaterial = new THREE.MeshPhongMaterial({
          color: BODY_COLORS[bodyIndex],
          shininess: 30,
          emissive: new THREE.Color(BODY_COLORS[bodyIndex]).multiplyScalar(0.2)
        });
        
        const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
        bodyMesh.position.copy(bodies[bodyIndex].position);
        bodyMesh.castShadow = true;
        bodyMesh.receiveShadow = true;
        bodyMesh.userData = { 
          bodyIndex: bodyIndex,
          type: 'body' 
        };
        
        scene.add(bodyMesh);
        bodyMeshes[bodyIndex] = bodyMesh;
        
        // Update drag controls
        setupDragControls();
        
        // Render the scene to reflect changes
        renderScene();
      }
      
      // Helper function to update velocity
      function updateBodyVelocity(bodyIndex, component, value) {
        if (component === 'x') {
          initialVelocities[bodyIndex].x = value;
          bodies[bodyIndex].velocity.x = value;
        } else if (component === 'z') {
          initialVelocities[bodyIndex].z = value;
          bodies[bodyIndex].velocity.z = value;
        }
        
        // Update velocity arrow
        updateVelocityArrow(bodyIndex);
        
        // Render the scene to reflect changes
        renderScene();
      }

      // Reset to the default configuration
      function resetDefault() {
        // Stop animation
        isAnimating = false;
        isPaused = false;
        simulationTime = 0;
        collisionOccurred = false;
        
        // Enable start button, disable stop button
        document.getElementById('startButton').disabled = false;
        document.getElementById('stopButton').disabled = true;
        
        // Reset pause button text
        document.getElementById('pauseButton').textContent = 'Pause';
        
        // Reset Borderless mode
        if (freePlayMode) {
          freePlayMode = false;
          document.getElementById('freePlayButton').classList.remove('active');
          document.getElementById('freePlayButton').textContent = 'Toggle Borderless';
          boundaryPlane.visible = true;
          window.boundaryGrid.visible = true;
          window.boundaryRing.visible = true;
          window.largeGrid.visible = false;
          window.largePlane.visible = false;
        }
        
        // Hide reset buttons
        document.getElementById('resetButtonRow').style.display = 'none';
        document.getElementById('resetLastButton').style.display = 'none';
        document.getElementById('resetDefaultButton').style.display = 'none';
        
        // Set up default configuration
        // Central star with two orbiting bodies
        initialPositions[0].set(-5, 0, 0);     // Left body
        initialPositions[1].set(5, 0, 0);      // Right body
        initialPositions[2].set(0, 0, 0);      // Center body
        
        initialVelocities[0].set(0, 0, 0.42);  // Left body moving up
        initialVelocities[1].set(0, 0, -0.42); // Right body moving down
        initialVelocities[2].set(0, 0, 0);     // Center body stationary
        
        masses[0] = 1.0;  // Left body mass
        masses[1] = 1.0;  // Right body mass
        masses[2] = 1.5;  // Center body mass (heavier)
        
        // Update bodies with default settings
        for (let i = 0; i < 3; i++) {
          bodies[i].position.copy(initialPositions[i]);
          bodies[i].velocity.copy(initialVelocities[i]);
          bodies[i].mass = masses[i];
          
          // Clear previous trail positions but keep the array
          bodies[i].trail = [];
          // Save the initial position into the trail
          bodies[i].trail.push(initialPositions[i].clone());
          
          // Remove old mesh
          scene.remove(bodyMeshes[i]);
          
          // Create new mesh with updated size based on mass
          const size = getBodyRadius(masses[i]);
          const bodyGeometry = new THREE.SphereGeometry(size, 32, 32);
          const bodyMaterial = new THREE.MeshPhongMaterial({
            color: BODY_COLORS[i],
            shininess: 30,
            emissive: new THREE.Color(BODY_COLORS[i]).multiplyScalar(0.2)
          });
          
          const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
          bodyMesh.position.copy(initialPositions[i]);
          bodyMesh.castShadow = true;
          bodyMesh.receiveShadow = true;
          bodyMesh.userData = { 
            bodyIndex: i,
            type: 'body' 
          };
          
          scene.add(bodyMesh);
          bodyMeshes[i] = bodyMesh;
        }
        
        // Update mass sliders to reflect default values
        updateMassSliders();
        
        // Update velocity arrows after body meshes are updated
        for (let i = 0; i < 3; i++) {
          updateVelocityArrow(i);
          velocityArrows[i].head.visible = true;
          velocityArrows[i].line.visible = true;
        }
        
        // Reset trail system
        createTrailSystem();
        
        // Enable orbit controls
        controls.enabled = true;
        
        // Reset to angled view
        setAngledView();
        
        // Reinitialize drag controls to ensure they're fresh
        setupDragControls();
        
        // Hide real-time velocity displays
        for (let i = 0; i < bodies.length; i++) {
          const velocityDisplay = document.getElementById(`body${i+1}RealTimeVelocity`);
          
          if (velocityDisplay) {
            velocityDisplay.style.display = 'none';
            
            // Reset content and arrow
            velocityDisplay.innerHTML = `
              Velocity:
              <div class="velocity-content">
                <div class="velocity-text">X: 0.00&nbsp;&nbsp;Y: 0.00</div>
                <div class="velocity-arrow-container">
                  <div id="body${i+1}VelocityArrow" class="velocity-arrow body${i+1}"></div>
                </div>
              </div>
            `;
          }
        }
        
        // Render the reset scene
        renderScene();
      }

      // Function to update real-time velocity displays
      function updateRealTimeVelocityDisplay(bodyIndex) {
        const body = bodies[bodyIndex];
        const display = document.getElementById(`body${bodyIndex+1}RealTimeVelocity`);
        
        if (display && body) {
          // Calculate velocity magnitude and direction
          const velX = body.velocity.x;
          const velY = body.velocity.z;
          const xVal = velX.toFixed(2);
          const yVal = velY.toFixed(2);
          
          // Calculate magnitude
          const magnitude = Math.sqrt(velX * velX + velY * velY);
          
          // Get the color for this body
          let arrowColor;
          if (bodyIndex === 0) arrowColor = '#d8a0ff';
          else if (bodyIndex === 1) arrowColor = '#ffb6c1';
          else arrowColor = '#87cefa';
          
          // Set arrow length based on velocity magnitude
          const minLength = 3;
          const maxLength = 200;
          const lengthScale = 30;
          
          // Using square root of magnitude for better visualization of small changes
          const sqrtMagnitude = Math.sqrt(magnitude);
          const length = Math.max(minLength, Math.min(maxLength, sqrtMagnitude * lengthScale));
          
          // Calculate angle in radians
          const angle = Math.atan2(velY, velX) * (180 / Math.PI); // Convert to degrees for CSS
          
          // Log for debugging
          console.log(`Body ${bodyIndex+1}: Magnitude ${magnitude.toFixed(4)}, Arrow length ${length.toFixed(1)}px, Angle ${angle.toFixed(1)}°`);
          
          // Create HTML for display - always show as triangle with current direction
          const velocityHTML = `
            Velocity:
            <div class="velocity-content">
              <div class="velocity-text">X: ${xVal.padStart(6)}  Y: ${yVal.padStart(6)}</div>
              <div class="velocity-arrow-container">
                <div style="
                  position: absolute;
                  top: 50%;
                  left: 50%;
                  width: 0;
                  height: 0;
                  border-left: ${length}px solid ${arrowColor};
                  border-top: 6px solid transparent;
                  border-bottom: 6px solid transparent;
                  transform: translateX(-12px) rotate(${angle}deg);
                  transform-origin: center left;
                "></div>
              </div>
            </div>
          `;
          
          // Replace the entire display content
          display.innerHTML = velocityHTML;
        }
      }

      // Set angled view with proper zoom (zoomed in 15% from default)
      function setAngledView() {
        // Default position was (50, 50, 50)
        // Reduce by 15% to zoom in
        const zoomFactor = 0.85; // 15% closer
        setCamera(new THREE.Vector3(50 * zoomFactor, 50 * zoomFactor, 50 * zoomFactor));
      }

      // Instructions toggling
      document.getElementById('helpHeader').addEventListener('click', function() {
        const content = document.getElementById('helpContent');
        const toggleButton = document.getElementById('toggleHelpButton');
        content.classList.toggle('collapsed');
        toggleButton.textContent = content.classList.contains('collapsed') ? '▲' : '▼';
      });

      // Initialize with showing velocity
      function initializeRealTimeVelocity() {
        for (let i = 0; i < 3; i++) {
          updateRealTimeVelocityDisplay(i);
          // Make sure the velocity display is visible
          const velocityDisplay = document.getElementById(`body${i+1}RealTimeVelocity`);
          if (velocityDisplay) {
            velocityDisplay.style.display = 'block';
          }
        }
      }

      // Enhanced cinematic mode with camera cuts
      let lastCameraCutTime = 0;
      let currentCameraView = 'angled';
      const cameraCutInterval = 5000; // Time between camera cuts in ms

      function applyCinematicCameraMovement() {
        if (!cinematicMode) return;
        
        const now = Date.now();
        const timeSinceLastCut = now - lastCameraCutTime;
        
        // Apply subtle continuous movement regardless of camera mode
        const time = now * 0.0001;
        camera.position.x = camera.position.x + Math.sin(time) * 0.05;
        camera.position.z = camera.position.z + Math.cos(time) * 0.05;
        
        // Occasionally cut to new camera views
        if (timeSinceLastCut > cameraCutInterval) {
          // Choose a random camera view that's different from the current one
          const views = ['angled', 'top', 'side', 'follow1', 'follow2', 'follow3', 'wide'];
          let newView;
          
          do {
            newView = views[Math.floor(Math.random() * views.length)];
          } while (newView === currentCameraView);
          
          // Set the new camera view
          switch (newView) {
            case 'angled':
              setAngledView();
              break;
            case 'top':
              setCamera(new THREE.Vector3(0, 75, 0.1));
              break;
            case 'side':
              // Add 3-degree angle to side view (converting to radians)
              const angleRadians = 3 * (Math.PI / 180);
              const sideX = 75;
              const sideY = sideX * Math.tan(angleRadians); // Calculate Y offset for 3-degree angle
              setCamera(new THREE.Vector3(sideX, sideY, 0));
              break;
            case 'follow1':
              followBody(0);
              break;
            case 'follow2':
              followBody(1);
              break;
            case 'follow3':
              followBody(2);
              break;
            case 'wide':
              setCamera(new THREE.Vector3(100, 100, 100));
              break;
          }
          
          // Save the current view and time
          currentCameraView = newView;
          lastCameraCutTime = now;
          
          // Keep cinematic mode active regardless of view changes
          cinematicMode = true;
          document.getElementById('cinematicButton').classList.add('active');
        }
        
        // Always look at what we should be looking at
        if (isFollowing) {
          // If following a body, keep looking at it
          const bodyToFollow = bodies[followingBodyIndex];
          
          // Add cinematic wobble to the follow offset
          const wobbleX = Math.sin(time * 0.8) * 2;
          const wobbleY = Math.cos(time * 0.7) * 1.5;
          const wobbleZ = Math.sin(time * 0.9) * 2;
          
          const offset = new THREE.Vector3(wobbleX, 15 + wobbleY, 25 + wobbleZ);
          camera.position.copy(bodyToFollow.position).add(offset);
          camera.lookAt(bodyToFollow.position);
          controls.target.copy(bodyToFollow.position);
        } else {
          // Otherwise look at the scene center
          camera.lookAt(scene.position);
        }
      }

      // Function to format mass value display with appropriate precision
      function formatMassValue(value) {
        if (value < 10) {
          return value.toFixed(1); // One decimal for small values
        } else if (value < 100) {
          return value.toFixed(0); // Whole numbers for medium values
        } else {
          return value.toFixed(0); // Whole numbers for large values
        }
      }

      window.onload = function() {
        init();
        setupScene();
        initControls();
        
        // Hide reset button row initially
        document.getElementById('resetButtonRow').style.display = 'none';
        
        // Ensure help content is collapsed by default
        document.getElementById('helpContent').classList.add('collapsed');
        document.getElementById('toggleHelpButton').textContent = '▲';
        
        // Set initial status message
        updateStatusMessage('Ready');
      };
    </script>
    
    <button id="ui-toggle">Hide UI</button>
  </body>
</html>
