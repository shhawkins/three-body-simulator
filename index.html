<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three Body Problem Simulator</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
        background-color: #000;
        color: #fff;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
      }
      
      /* Fixed 16:9 aspect ratio container */
      #container {
        position: relative;
        width: 100%;
        max-width: 177.78vh; /* 16:9 aspect ratio */
        height: 100%;
        max-height: 56.25vw; /* 16:9 aspect ratio */
        margin: auto;
      }
      
      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }
      
      #controls {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: rgba(30, 39, 46, 0.85);
        padding: 15px;
        border-radius: 8px;
        z-index: 100;
        max-width: 340px;
        backdrop-filter: blur(5px);
      }
      
      .control-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        margin-bottom: 10px;
      }
      
      .control-header h3 {
        margin: 0;
        color: #ecf0f1;
      }
      
      .toggle-controls, .toggle-speed, .toggle-camera, .toggle-mass {
        font-size: 16px;
        background: none !important;
        border: none;
        color: #ecf0f1;
        cursor: pointer;
        padding: 0 !important;
        margin: 0 !important;
      }
      
      .control-content {
        overflow: hidden;
        transition: max-height 0.3s ease-out;
        max-height: 1000px;
      }
      
      .control-content.collapsed {
        max-height: 0;
      }
      
      .button {
        display: inline-block;
        margin: 5px;
        padding: 8px 15px;
        background-color: #2c3e50;
        color: #fff;
        text-decoration: none;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      
      .button:hover {
        background-color: #34495e;
      }
      
      #startButton {
        background-color: #2980b9;
      }
      
      #startButton:hover {
        background-color: #3498db;
      }
      
      #stopButton {
        background-color: #c0392b;
      }
      
      #stopButton:hover {
        background-color: #e74c3c;
      }
      
      #pauseButton {
        background-color: #8e44ad;
      }
      
      #pauseButton:hover {
        background-color: #9b59b6;
      }
      
      #resetLastButton {
        background-color: #16a085;
      }
      
      #resetLastButton:hover {
        background-color: #1abc9c;
      }
      
      #resetDefaultButton {
        background-color: #2c3e50;
      }
      
      #resetDefaultButton:hover {
        background-color: #34495e;
      }
      
      #toggleTrailsButton {
        background-color: #7f8c8d;
      }
      
      #toggleTrailsButton:hover {
        background-color: #95a5a6;
      }
      
      input[type="number"], input[type="range"] {
        width: 100px;
        margin: 5px;
        padding: 5px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }
      
      .body-controls {
        margin-top: 15px;
        border-top: 1px solid rgba(255, 255, 255, 0.3);
        padding-top: 10px;
        transition: height 0.3s, opacity 0.3s;
        overflow: hidden;
      }
      
      .body-controls.hidden {
        height: 0;
        opacity: 0;
        padding: 0;
        margin: 0;
        pointer-events: none;
      }
      
      .body-section {
        margin-bottom: 10px;
        padding: 8px;
        border-radius: 4px;
        background-color: rgba(255, 255, 255, 0.1);
      }
      
      .mass-slider-container {
        display: flex;
        align-items: center;
        margin: 10px 0;
      }
      
      .mass-slider {
        flex-grow: 1;
        height: 6px;
        -webkit-appearance: none;
        background: rgba(255, 255, 255, 0.3);
        outline: none;
        border-radius: 3px;
        margin: 0 10px;
      }
      
      .mass-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        cursor: pointer;
      }
      
      #body1MassSlider::-webkit-slider-thumb {
        background: #ff5252;
      }
      
      #body2MassSlider::-webkit-slider-thumb {
        background: #7b68ee;
      }
      
      #body3MassSlider::-webkit-slider-thumb {
        background: #4fc3f7;
      }
      
      .mass-value {
        width: 30px;
        text-align: center;
      }
      
      .velocity-inputs {
        margin-top: 5px;
      }
      
      /* Hide the original number inputs that we're replacing */
      .hidden-input {
        display: none;
      }
      
      /* Instructions tooltip */
      .tooltip {
        position: absolute;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 0.9em;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s;
        width: max-content;
        max-width: 200px;
        z-index: 100;
      }
      
      /* Styles for draggable elements */
      .draggable {
        cursor: move;
      }
      
      /* Re-add camera controls styles */
      #camera-controls {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background-color: rgba(30, 39, 46, 0.85);
        padding: 10px;
        padding-top: 0;
        border-radius: 8px;
        z-index: 100;
        backdrop-filter: blur(5px);
        max-height: 200px;
        transition: max-height 0.3s ease-out;
        overflow: hidden;
      }
      
      #camera-controls.collapsed {
        max-height: 40px;
      }
      
      .camera-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        padding: 5px 10px;
      }
      
      .camera-header h4 {
        margin: 5px 0;
        color: #ecf0f1;
      }
      
      .camera-content {
        padding: 5px 0;
        overflow: hidden;
      }
      
      #camera-controls.collapsed .camera-content {
        height: 0;
        padding: 0;
      }
      
      .toggle-camera {
        font-size: 16px;
        background: none !important;
        border: none;
        color: white;
        cursor: pointer;
        padding: 0 !important;
        margin: 0 !important;
      }
      
      #status {
        position: absolute;
        bottom: 10px;
        right: 10px;
        padding: 8px 15px;
        background-color: rgba(0, 0, 0, 0.7);
        border-radius: 8px;
        backdrop-filter: blur(5px);
      }
      
      #simulation-time {
        position: absolute;
        top: 10px;
        right: 10px;
        padding: 8px 15px;
        background-color: rgba(0, 0, 0, 0.7);
        border-radius: 8px;
        backdrop-filter: blur(5px);
      }
      
      .button-group {
        margin-bottom: 15px;
      }
      
      .preset-config {
        margin: 15px 0;
        padding: 10px;
        background-color: rgba(255, 255, 255, 0.1);
        border-radius: 5px;
      }
      
      .select-dropdown {
        width: 100%;
        padding: 8px;
        margin-top: 5px;
        margin-bottom: 8px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        border: 1px solid #555;
        border-radius: 4px;
        cursor: pointer;
      }
      
      .select-dropdown:focus {
        outline: none;
        border-color: #4caf50;
      }
      
      #help-text {
        position: absolute;
        bottom: 50px;
        right: 10px;
        padding: 8px;
        background-color: rgba(30, 39, 46, 0.85);
        border-radius: 8px;
        font-size: 0.8em;
        max-width: 300px;
        opacity: 0.9;
        backdrop-filter: blur(5px);
      }
      
      #mass-controls {
        position: absolute;
        top: 10px;
        right: 10px;
        background-color: rgba(30, 39, 46, 0.85);
        padding: 10px;
        padding-top: 0;
        border-radius: 8px;
        z-index: 100;
        max-width: 340px;
        backdrop-filter: blur(5px);
        max-height: 500px;
        transition: max-height 0.3s ease-out;
        overflow: hidden;
      }
      
      #mass-controls.collapsed {
        max-height: 40px;
      }
      
      .mass-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        padding: 5px 10px;
      }
      
      .mass-header h4 {
        color: #ecf0f1;
        margin: 5px 0;
      }
      
      .mass-content {
        padding: 5px 0;
        overflow: hidden;
      }
      
      #mass-controls.collapsed .mass-content {
        height: 0;
        padding: 0;
      }
      
      .toggle-mass {
        font-size: 16px;
        background: none !important;
        border: none;
        color: #ecf0f1;
        cursor: pointer;
        padding: 0 !important;
        margin: 0 !important;
      }
      
      .speed-controls {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(30, 39, 46, 0.85);
        padding: 10px;
        padding-top: 0;
        border-radius: 8px;
        z-index: 100;
        backdrop-filter: blur(5px);
        text-align: center;
        max-height: 200px;
        transition: max-height 0.3s ease-out;
        overflow: hidden;
      }
      
      .speed-controls.collapsed {
        max-height: 40px;
      }
      
      .speed-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        padding: 5px 10px;
      }
      
      .speed-header h4 {
        margin: 5px 0;
        color: #ecf0f1;
      }
      
      .toggle-speed {
        font-size: 16px;
        background: none;
        border: none;
        color: white;
        cursor: pointer;
      }
      
      .speed-button {
        background-color: #2c3e50;
        color: #fff;
        border: 2px solid transparent;
        border-radius: 4px;
        padding: 8px 15px;
        margin: 5px;
        cursor: pointer;
        transition: all 0.2s;
      }
      
      .speed-button:hover {
        background-color: #34495e;
      }
      
      .speed-active {
        border: 2px solid #ecf0f1 !important;
        box-shadow: 0 0 8px rgba(149, 165, 166, 0.7);
      }
      
      #slowSpeedButton {
        background-color: #1a237e;
      }
      
      #slowSpeedButton:hover {
        background-color: #283593;
      }
      
      #normalSpeedButton {
        background-color: #0d47a1;
      }
      
      #normalSpeedButton:hover {
        background-color: #1565c0;
      }
      
      #fastSpeedButton {
        background-color: #4a148c;
      }
      
      #fastSpeedButton:hover {
        background-color: #6a1b9a;
      }
      
      #veryFastSpeedButton {
        background-color: #880e4f;
      }
      
      #veryFastSpeedButton:hover {
        background-color: #ad1457;
      }
      
      #superFastSpeedButton {
        background-color: #b71c1c;
      }
      
      #superFastSpeedButton:hover {
        background-color: #c62828;
      }
      
      #camera-controls button {
        margin: 5px;
        padding: 8px 15px;
        background-color: #263238;
        color: #fff;
        text-decoration: none;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
      
      #camera-controls button:hover {
        background-color: #37474f;
      }
      
      #topViewButton {
        background-color: #01579b;
      }
      
      #topViewButton:hover {
        background-color: #0277bd;
      }
      
      #sideViewButton {
        background-color: #4a148c;
      }
      
      #sideViewButton:hover {
        background-color: #6a1b9a;
      }
      
      #angledViewButton {
        background-color: #1b5e20;
      }
      
      #angledViewButton:hover {
        background-color: #2e7d32;
      }
      
      #followBody1Button {
        background-color: #b71c1c;
      }
      
      #followBody1Button:hover {
        background-color: #c62828;
      }
      
      #followBody2Button {
        background-color: #4527a0;
      }
      
      #followBody2Button:hover {
        background-color: #5e35b1;
      }
      
      #followBody3Button {
        background-color: #01579b;
      }
      
      #followBody3Button:hover {
        background-color: #0288d1;
      }
      
      .speed-content {
        padding: 5px 0;
        overflow: hidden;
      }
      
      .speed-controls.collapsed .speed-content {
        height: 0;
        padding: 0;
      }
      
      #cinematicButton {
        background-color: #311b92;
      }
      
      #cinematicButton:hover {
        background-color: #4527a0;
      }
      
      #cinematicButton.active {
        border: 2px solid #ecf0f1 !important;
        background-color: #5e35b1;
        box-shadow: 0 0 8px rgba(149, 165, 166, 0.7);
      }
    </style>
    <script
      async
      src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"
    ></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
          "lodash": "https://cdn.jsdelivr.net/npm/lodash@4.17.21/+esm",
          "gsap": "https://cdn.jsdelivr.net/npm/gsap@3.12.4/+esm",
          "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/+esm",
          "d3": "https://cdn.jsdelivr.net/npm/d3@7.8.5/+esm",
          "chart.js": "https://cdn.jsdelivr.net/npm/chart.js@4.4.0/+esm"
        }
      }
    </script>
  </head>
  <body>
    <div id="container">
      <!-- Canvas will be inserted here by Three.js -->
      
    <div id="controls">
        <div class="control-header" id="controlHeader">
          <h3>Three Body Problem Simulator</h3>
          <button class="toggle-controls" id="toggleControlsButton">▼</button>
        </div>
        <div class="control-content" id="controlContent">
          <div class="button-group">
      <button id="startButton" class="button">Start</button>
            <button id="stopButton" class="button">Stop</button>
      <button id="pauseButton" class="button">Pause</button>
            <button id="resetLastButton" class="button" style="display: none;">Reset (Previous)</button>
            <button id="resetDefaultButton" class="button" style="display: none;">Reset (Default)</button>
            <button id="toggleTrailsButton" class="button">Hide Trails</button>
          </div>
        </div>
    </div>
    
    <div class="speed-controls" id="speedControls">
      <div class="speed-header" id="speedHeader">
        <h4>Simulation Speed</h4>
        <button class="toggle-speed" id="toggleSpeedButton">▼</button>
      </div>
      <div class="speed-content" id="speedContent">
        <button id="slowSpeedButton" class="speed-button">Slow</button>
        <button id="normalSpeedButton" class="speed-button speed-active">Normal</button>
        <button id="fastSpeedButton" class="speed-button">Fast</button>
        <button id="veryFastSpeedButton" class="speed-button">Very Fast</button>
        <button id="superFastSpeedButton" class="speed-button">Super Fast</button>
      </div>
    </div>

    <div id="camera-controls">
      <div class="camera-header" id="cameraHeader">
        <h4>Camera Controls</h4>
        <button class="toggle-camera" id="toggleCameraButton">▼</button>
      </div>
      <div class="camera-content" id="cameraContent">
      <button id="topViewButton">Top View</button>
      <button id="sideViewButton">Side View</button>
      <button id="angledViewButton">Angled View</button>
        <div>
          <button id="followBody1Button">Follow Body 1</button>
          <button id="followBody2Button">Follow Body 2</button>
          <button id="followBody3Button">Follow Body 3</button>
        </div>
        <div>
          <button id="cinematicButton">Cinematic Mode</button>
        </div>
      </div>
    </div>
    
    <div id="help-text" style="max-width: 320px; margin-bottom: 10px;">
      <div class="help-header" id="helpHeader" style="display: flex; align-items: center; cursor: pointer;">
        <h4 style="margin: 0; font-size: 1em;">Instructions</h4>
      </div>
      <div class="help-content" id="helpContent" style="font-size: 0.95em; padding-top: 4px;">
        <ol style="margin: 0 0 0.5em 1.2em; padding: 0;">
          <li>Drag bodies to position</li>
          <li>Drag arrow to set velocity</li>
          <li>Click <b>Start</b> (upper left)</li>
        </ol>
        <h5>DON'T COLLIDE!</h5>
        <ul style="margin: 0 0 0.5em 1.2em; padding: 0; list-style: disc;">
          <li>Click and drag to rotate view</li>
          <li>Scroll to zoom</li>
          <li>By default, orbit is stable</li>
          <li>Try subtle changes for interesting results</li>
          <li>You can adjust during simulation!</li>
        </ul>
      </div>
    </div>

    <div id="mass-controls">
      <div class="mass-header" id="massHeader">
        <h4>Body Controls</h4>
        <button class="toggle-mass" id="toggleMassButton">▼</button>
      </div>
      <div class="mass-content" id="massContent">
        <div class="body-controls" id="bodyControls">
          <div class="body-section" style="border-left: 4px solid #d8a0ff;">
            <label>Body 1 Mass:</label>
            <div class="mass-slider-container">
              <span>0.1</span>
              <input type="range" id="body1MassSlider" class="mass-slider" min="0.1" max="5" step="0.1" value="1">
              <span class="mass-value" id="body1MassValue">1.0</span>
            </div>
            <input type="number" id="body1Mass" value="1" step="0.1" min="0.1" max="5" class="hidden-input">
            
            <div class="velocity-inputs">
              <p>Velocity: Drag the arrow to adjust</p>
              <input type="number" id="body1VelocityX" value="0" step="0.1" class="hidden-input">
              <input type="number" id="body1VelocityZ" value="0.5" step="0.1" class="hidden-input">
            </div>
          </div>
          
          <div class="body-section" style="border-left: 4px solid #ffb6c1;">
            <label>Body 2 Mass:</label>
            <div class="mass-slider-container">
              <span>0.1</span>
              <input type="range" id="body2MassSlider" class="mass-slider" min="0.1" max="5" step="0.1" value="1">
              <span class="mass-value" id="body2MassValue">1.0</span>
            </div>
            <input type="number" id="body2Mass" value="1" step="0.1" min="0.1" max="5" class="hidden-input">
            
            <div class="velocity-inputs">
              <p>Velocity: Drag the arrow to adjust</p>
              <input type="number" id="body2VelocityX" value="0" step="0.1" class="hidden-input">
              <input type="number" id="body2VelocityZ" value="-0.5" step="0.1" class="hidden-input">
            </div>
          </div>
          
          <div class="body-section" style="border-left: 4px solid #87cefa;">
            <label>Body 3 Mass:</label>
            <div class="mass-slider-container">
              <span>0.1</span>
              <input type="range" id="body3MassSlider" class="mass-slider" min="0.1" max="5" step="0.1" value="1">
              <span class="mass-value" id="body3MassValue">1.0</span>
            </div>
            <input type="number" id="body3Mass" value="1" step="0.1" min="0.1" max="5" class="hidden-input">
            
            <div class="velocity-inputs">
              <p>Velocity: Drag the arrow to adjust</p>
              <input type="number" id="body3VelocityX" value="0.5" step="0.1" class="hidden-input">
              <input type="number" id="body3VelocityZ" value="0" step="0.1" class="hidden-input">
            </div>
          </div>
        </div>
      </div>
    </div>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { DragControls } from "three/addons/controls/DragControls.js";
      import _ from "lodash";
      import { gsap } from "gsap";

      // ------------------------------------------------
      // Constants and configuration
      // ------------------------------------------------
      const BOUNDARY_RADIUS = 60; // Defines the outer circular boundary
      const G = 0.3; // Gravitational constant
      let simulationSpeed = 0.25; // Default simulation speed
      const BODY_COLORS = [
        0xd8a0ff, // Light purple for Body A
        0xffb6c1, // Light pink for Body B
        0x87cefa  // Light blue for Body C
      ];
      const TRAIL_COLORS = [
        { start: 0xd8a0ff, end: 0x8a2be2 }, // Light purple → Dark purple gradient
        { start: 0xffb6c1, end: 0xff1493 }, // Light pink → Dark pink gradient
        { start: 0x87cefa, end: 0x0000cd }  // Light blue → Dark blue gradient
      ];

      // ------------------------------------------------
      // Scene setup
      // ------------------------------------------------
      // Create a container with 16:9 aspect ratio
      const container = document.getElementById('container');
      const aspectRatio = 16 / 9;
      
      // Determine size based on window dimensions
      let width, height;
      if (window.innerWidth / window.innerHeight > aspectRatio) {
        // Window is wider than 16:9
        height = window.innerHeight;
        width = height * aspectRatio;
      } else {
        // Window is taller than 16:9
        width = window.innerWidth;
        height = width / aspectRatio;
      }

      // Initialize scene, camera, and renderer
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(width, height);
      renderer.setPixelRatio(window.devicePixelRatio);
      container.appendChild(renderer.domElement);

      // Set initial camera position and controls
      camera.position.set(0, 42, 50);
      camera.lookAt(0, 0, 0);
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      
      // Ensure camera controls are always enabled
      controls.enabled = true;
      controls.enableZoom = true;
      controls.enableRotate = true;
      
      // Disable features we don't want
      controls.enableKeys = false;
      controls.enablePan = false;

      // ------------------------------------------------
      // Lighting and environment
      // ------------------------------------------------
      // Add ambient and directional light
      const ambientLight = new THREE.AmbientLight(0x404040);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(0, 10, 10);
      scene.add(directionalLight);

      // Create a starfield background
      function createStarfield() {
        const starGeometry = new THREE.BufferGeometry();
        const starCount = 5000;
        const starPositions = [];
        const starSizes = [];
        
        for (let i = 0; i < starCount; i++) {
          // Create stars in a spherical distribution
          const radius = 100 + Math.random() * 100;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          
          const x = radius * Math.sin(phi) * Math.cos(theta);
          const y = radius * Math.sin(phi) * Math.sin(theta);
          const z = radius * Math.cos(phi);
          
          starPositions.push(x, y, z);
          starSizes.push(Math.random() * 2);
        }
        
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
        starGeometry.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));
        
        const starMaterial = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 0.5,
          sizeAttenuation: true
        });
        
        const starField = new THREE.Points(starGeometry, starMaterial);
        scene.add(starField);
      }
      
      createStarfield();

      // Create the circular boundary plane
      function createBoundaryPlane() {
        const planeGeometry = new THREE.CircleGeometry(BOUNDARY_RADIUS, 64);
        const planeMaterial = new THREE.MeshStandardMaterial({
          color: 0x222222,
          transparent: true,
          opacity: 0.5,
          roughness: 0.7
        });
        
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2; // Rotate to horizontal
        plane.position.y = 0;
        scene.add(plane);
        
        // Add a grid on top of the plane for reference
        const gridHelper = new THREE.GridHelper(BOUNDARY_RADIUS * 2, 20);
        gridHelper.position.y = 0.01; // Slightly above the plane
      scene.add(gridHelper);

        // Add a ring to highlight the boundary
        const ringGeometry = new THREE.RingGeometry(BOUNDARY_RADIUS - 0.1, BOUNDARY_RADIUS, 64);
        const ringMaterial = new THREE.MeshBasicMaterial({
          color: 0x3498db,
          side: THREE.DoubleSide
        });
        
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.rotation.x = -Math.PI / 2; // Rotate to horizontal
        ring.position.y = 0.02; // Slightly above the plane
        scene.add(ring);
        
        return plane;
      }
      
      const boundaryPlane = createBoundaryPlane();

      // ------------------------------------------------
      // Simulation state
      // ------------------------------------------------
      let masses = [1, 1, 1];
      let initialVelocities = [
        new THREE.Vector3(0, 0, 0.5),
        new THREE.Vector3(0, 0, -0.5),
        new THREE.Vector3(0, 0, 0),
      ];
      let initialPositions = [
        new THREE.Vector3(-5, 0, 0),
        new THREE.Vector3(5, 0, 0),
        new THREE.Vector3(0, 0, 0),
      ];

      // Simulation controls
      let isAnimating = false;
      let isPaused = false;
      let showTrails = true; // Show trails by default
      let simulationTime = 0;
      let animationId;
      let isFollowing = false;
      let followingBodyIndex = 0; // Which body to follow (0, 1, or 2)
      let collisionOccurred = false;
      let cinematicMode = false; // Track if cinematic camera mode is enabled

      // Trail parameters
      const MAX_TRAIL_LENGTH = 3000; // Fixed trail length
      let trails = [[], [], []];
      let trailMeshes = [null, null, null]; // Store trail meshes

      // Bodies
      let bodies = [];
      let bodyMeshes = [];
      let velocityArrows = [];

      // Object to hold tooltip for instructions
      let tooltip = null;

      // ------------------------------------------------
      // Create bodies
      // ------------------------------------------------
      function createBodies() {
        // Clear existing bodies if any
        bodyMeshes.forEach(mesh => {
          if (mesh) scene.remove(mesh);
        });
        
        velocityArrows.forEach(arrow => {
          if (arrow) scene.remove(arrow);
        });
        
        bodyMeshes = [];
        velocityArrows = [];
        bodies = [];
        
        // Create tooltip for instructions if it doesn't exist
        if (!tooltip) {
          tooltip = document.createElement('div');
          tooltip.className = 'tooltip';
          container.appendChild(tooltip);
        }
        
      for (let i = 0; i < 3; i++) {
          // Calculate size based on mass (for visual representation)
          const size = getBodyRadius(masses[i]);
          
          // Create sphere for the body
          const bodyGeometry = new THREE.SphereGeometry(size, 32, 32);
        const bodyMaterial = new THREE.MeshPhongMaterial({
            color: BODY_COLORS[i],
            shininess: 30,
            emissive: new THREE.Color(BODY_COLORS[i]).multiplyScalar(0.2)
        });
          
        const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
        bodyMesh.position.copy(initialPositions[i]);
          bodyMesh.castShadow = true;
          bodyMesh.receiveShadow = true;
          bodyMesh.userData = { 
            bodyIndex: i,
            type: 'body' 
          };
          
        scene.add(bodyMesh);
        bodyMeshes.push(bodyMesh);

          // Create velocity arrow
          const arrowDirection = initialVelocities[i].clone().normalize();
          // Create arrows with sufficient length for visibility and interaction
          const baseLength = 3; // Increased from 2 for better interaction
          const velocityScale = 4; // Increased from 3 for better visibility
          let arrowLength = baseLength;
          if (initialVelocities[i].length() > 0) {
            arrowLength = baseLength + initialVelocities[i].length() * velocityScale;
          }
          
          const arrowHead = new THREE.Mesh(
            new THREE.ConeGeometry(0.5, 1.0, 8), // Increased size for easier interaction
            new THREE.MeshBasicMaterial({ color: BODY_COLORS[i] })
          );
          
          // Position the arrow head away from the body for better visibility
          const arrowHeadPosition = initialPositions[i].clone().add(
            arrowDirection.clone().multiplyScalar(arrowLength)
          );
          arrowHead.position.copy(arrowHeadPosition);
          
          // Orient the arrow head to point in the velocity direction
          if (arrowDirection.length() > 0) {
            // Calculate a point that continues in the direction from body to arrow
            const targetLook = arrowHead.position.clone().add(arrowDirection);
            arrowHead.lookAt(targetLook);
            arrowHead.rotateX(Math.PI / 2);
          }
          
          // Store arrowhead information for dragging and updating
          arrowHead.userData = {
            bodyIndex: i,
            type: 'velocityArrow',
            baseLength: baseLength,
            velocityScale: velocityScale
          };
          
          // Create arrow line
          const lineGeometry = new THREE.BufferGeometry().setFromPoints([
            initialPositions[i],
            arrowHeadPosition
          ]);
          const lineMaterial = new THREE.LineBasicMaterial({ color: BODY_COLORS[i] });
          const line = new THREE.Line(lineGeometry, lineMaterial);
          
          // Add to scene
          scene.add(arrowHead);
          scene.add(line);
          
          // Store arrow components
          velocityArrows.push({
            head: arrowHead,
            line: line,
            baseLength: baseLength,
            velocityScale: velocityScale
          });
          
          // Initialize body data
        bodies.push({
          position: initialPositions[i].clone(),
          velocity: initialVelocities[i].clone(),
          mass: masses[i],
            trail: []
          });
        }
        
        // Create drag controls
        setupDragControls();
        
        // Update the mass sliders to reflect current values
        updateMassSliders();
      }
      
      // Function to update mass sliders to match current values
      function updateMassSliders() {
        for (let i = 0; i < 3; i++) {
          const slider = document.getElementById(`body${i+1}MassSlider`);
          const valueDisplay = document.getElementById(`body${i+1}MassValue`);
          
          slider.value = masses[i];
          valueDisplay.textContent = masses[i].toFixed(1);
          
          // Also update the hidden input (useful for code that might still reference it)
          document.getElementById(`body${i+1}Mass`).value = masses[i];
        }
      }

      // ------------------------------------------------
      // Setup drag controls for positioning bodies and velocity arrows
      // ------------------------------------------------
      let currentDragControls = null;

      function setupDragControls() {
        // First dispose of any existing controls
        if (currentDragControls) {
          currentDragControls.deactivate();
          currentDragControls.dispose();
          currentDragControls = null;
        }
        
        // Get all draggable objects (bodies and arrow heads)
        const draggableObjects = [...bodyMeshes];
        
        // Add arrow heads
        velocityArrows.forEach(arrow => {
          draggableObjects.push(arrow.head);
        });
        
        // Create new drag controls
        currentDragControls = new DragControls(draggableObjects, camera, renderer.domElement);
        
        currentDragControls.addEventListener('hoveron', function(event) {
          // Change cursor and show tooltip
          document.body.style.cursor = 'grab';
          
          // Show appropriate tooltip based on object type
          if (event.object.userData.type === 'body') {
            showTooltip('Drag to position the body', event);
          } else if (event.object.userData.type === 'velocityArrow') {
            showTooltip('Drag to set velocity direction and magnitude', event);
          }
        });
        
        currentDragControls.addEventListener('hoveroff', function() {
          // Reset cursor and hide tooltip
          document.body.style.cursor = 'auto';
          hideTooltip();
        });
        
        currentDragControls.addEventListener('dragstart', function(event) {
          // Temporarily disable orbit controls ONLY while actively dragging
          controls.enabled = false;
          
          // Change cursor style
          document.body.style.cursor = 'grabbing';
          
          // Hide tooltip during drag
          hideTooltip();
        });
        
        currentDragControls.addEventListener('drag', function(event) {
          const objectType = event.object.userData.type;
          const bodyIndex = event.object.userData.bodyIndex;
          
          if (objectType === 'body') {
            // Dragging a body
            const position = event.object.position;
            
            // Calculate distance from center
            const distance = Math.sqrt(position.x * position.x + position.z * position.z);
            
            // If outside boundary, constrain to boundary
            if (distance > BOUNDARY_RADIUS) {
              const angle = Math.atan2(position.z, position.x);
              position.x = BOUNDARY_RADIUS * Math.cos(angle);
              position.z = BOUNDARY_RADIUS * Math.sin(angle);
            }
            
            // Fix Y position to 0 (on the plane)
            position.y = 0;
            
            // Update the corresponding body position
            bodies[bodyIndex].position.copy(position);
            initialPositions[bodyIndex].copy(position);
            
            // Update velocity arrow position
            updateVelocityArrow(bodyIndex);
          } 
          else if (objectType === 'velocityArrow') {
            // Dragging a velocity arrow
            const arrowHead = event.object;
            const bodyPosition = bodyMeshes[bodyIndex].position;
            
            // Fix Y position to maintain horizontal plane
            arrowHead.position.y = 0;
            
            // Calculate new velocity based on the arrow position relative to the body
            const direction = new THREE.Vector3().subVectors(
              arrowHead.position,
              bodyPosition
            );
            
            // Get base length and scale from userData
            const baseLength = arrowHead.userData.baseLength;
            const velocityScale = arrowHead.userData.velocityScale;
            
            // Calculate actual direction length minus base length
            const totalLength = direction.length();
            let velocityMagnitude = 0;
            
            if (totalLength > baseLength) {
              velocityMagnitude = (totalLength - baseLength) / velocityScale;
            }
            
            // Normalize and scale to get new velocity
            if (direction.length() > 0) {
              direction.normalize();
              
              // Set new velocity
              const newVelocity = direction.multiplyScalar(velocityMagnitude);
              bodies[bodyIndex].velocity.copy(newVelocity);
              initialVelocities[bodyIndex].copy(newVelocity);
              
              // Orient arrow head
              if (direction.length() > 0) {
                // Calculate a point that continues in the direction from body to arrow
                const targetLook = arrowHead.position.clone().add(direction);
                arrowHead.lookAt(targetLook);
                arrowHead.rotateX(Math.PI / 2);
              }
              
              // Update velocity inputs
              updateVelocityInputs(bodyIndex, newVelocity);
            }
            
            // Update the line of the arrow
            updateVelocityArrowLine(bodyIndex);
          }
          
          // Update render
          renderScene();
        });
        
        currentDragControls.addEventListener('dragend', function(event) {
          // Always re-enable orbit controls
          controls.enabled = true;
          
          // Reset cursor
          document.body.style.cursor = 'auto';
          
          // Update positions and velocities for reset
          const objectType = event.object.userData.type;
          const bodyIndex = event.object.userData.bodyIndex;
          
          if (objectType === 'body') {
            initialPositions[bodyIndex].copy(event.object.position);
          } 
          else if (objectType === 'velocityArrow') {
            // Final update of velocity arrow and line
            updateVelocityArrow(bodyIndex);
          }
        });
      }
      
      // Function to update the velocity arrow based on current velocity
      function updateVelocityArrow(bodyIndex) {
        const arrow = velocityArrows[bodyIndex];
        const bodyPosition = bodyMeshes[bodyIndex].position;
        const velocity = bodies[bodyIndex].velocity;
        
        // Calculate arrow direction and length
        let arrowDirection;
        if (velocity.length() > 0) {
          arrowDirection = velocity.clone().normalize();
        } else {
          // Default direction if velocity is zero
          arrowDirection = new THREE.Vector3(1, 0, 0);
        }
        
        // Calculate length based on velocity magnitude
        const baseLength = arrow.baseLength;
        const velocityScale = arrow.velocityScale;
        const arrowLength = baseLength + velocity.length() * velocityScale;
        
        // Position arrow head
        const arrowHeadPosition = bodyPosition.clone().add(
          arrowDirection.clone().multiplyScalar(arrowLength)
        );
        arrow.head.position.copy(arrowHeadPosition);
        
        // Orient arrow head
        if (velocity.length() > 0) {
          // Calculate a point that continues in the direction from body to arrow
          const targetLook = arrowHeadPosition.clone().add(arrowDirection);
          arrow.head.lookAt(targetLook);
          arrow.head.rotateX(Math.PI / 2);
        }
        
        // Update line
        updateVelocityArrowLine(bodyIndex);
      }
      
      // Function to update just the line part of the velocity arrow
      function updateVelocityArrowLine(bodyIndex) {
        const arrow = velocityArrows[bodyIndex];
        const bodyPosition = bodyMeshes[bodyIndex].position;
        const arrowHeadPosition = arrow.head.position;
        
        // Update line geometry
        const points = [bodyPosition, arrowHeadPosition];
        arrow.line.geometry.dispose();
        arrow.line.geometry = new THREE.BufferGeometry().setFromPoints(points);
      }
      
      // Function to update velocity input fields
      function updateVelocityInputs(bodyIndex, velocity) {
        document.getElementById(`body${bodyIndex+1}VelocityX`).value = velocity.x.toFixed(2);
        document.getElementById(`body${bodyIndex+1}VelocityZ`).value = velocity.z.toFixed(2);
      }
      
      // Show tooltip with instructions
      function showTooltip(text, event) {
        if (tooltip) {
          tooltip.textContent = text;
          tooltip.style.opacity = '1';
          
          // Position tooltip near the mouse/object
          const rect = renderer.domElement.getBoundingClientRect();
          const mouseX = event.object.position.x;
          const mouseY = event.object.position.z;
          
          // Convert 3D position to screen position
          const vector = new THREE.Vector3(mouseX, 0, mouseY);
          vector.project(camera);
          
          const x = (vector.x * 0.5 + 0.5) * rect.width + rect.left;
          const y = -(vector.y * 0.5 - 0.5) * rect.height + rect.top;
          
          tooltip.style.left = x + 10 + 'px';
          tooltip.style.top = y + 10 + 'px';
        }
      }
      
      // Hide tooltip
      function hideTooltip() {
        if (tooltip) {
          tooltip.style.opacity = '0';
        }
      }

      // ------------------------------------------------
      // Trail management
      // ------------------------------------------------
      function createTrailSystem() {
        // Remove existing trails
        trailMeshes.forEach(mesh => {
          if (mesh) scene.remove(mesh);
        });
        
        trailMeshes = [null, null, null];
        
        for (let i = 0; i < 3; i++) {
          bodies[i].trail = [];
        }
      }

      function updateTrails() {
        for (let i = 0; i < 3; i++) {
          // Only update if showing trails
          if (!showTrails) {
            if (trailMeshes[i]) {
              scene.remove(trailMeshes[i]);
              trailMeshes[i] = null;
            }
            continue;
          }

          // Remove existing trail
          if (trailMeshes[i]) {
            scene.remove(trailMeshes[i]);
          }
          
          // Limit trail length
          if (bodies[i].trail.length > MAX_TRAIL_LENGTH) {
            bodies[i].trail = bodies[i].trail.slice(-MAX_TRAIL_LENGTH);
          }
          
          // Create new trail if we have enough points
          if (bodies[i].trail.length > 1) {
            // Use a tube geometry for more impressive trails
            const points = bodies[i].trail;
            
            // Create a smooth curve from points
            const curve = new THREE.CatmullRomCurve3(points);
            const tubeGeometry = new THREE.TubeGeometry(
              curve,
              Math.min(points.length * 2, 200), // Limit segments for performance
              0.15, // tube radius - thicker for better visibility
              8, // radial segments for roundness
              false // closed
            );
            
            // Create color gradient for trail
            const colors = [];
            const startColor = new THREE.Color(TRAIL_COLORS[i].start);
            const endColor = new THREE.Color(TRAIL_COLORS[i].end);
            
            const positionAttribute = tubeGeometry.getAttribute('position');
            const vertex = new THREE.Vector3();
            
            // For each vertex in the tube, assign a color
            for (let j = 0; j < positionAttribute.count; j++) {
              // Extract the vertex position
              vertex.fromBufferAttribute(positionAttribute, j);
              
              // Find the closest point on the curve to determine gradient position
              const t = curve.getUtoTmapping(j / positionAttribute.count);
              
              // Linear interpolation from start to end color, with bias toward start for a "fading tail" effect
              const ratio = Math.pow(t, 0.5); // Power for non-linear gradient
              const color = new THREE.Color().lerpColors(endColor, startColor, ratio);
              colors.push(color.r, color.g, color.b);
            }
            
            // Add the colors to the geometry
            tubeGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            // Create material with vertex colors
            const tubeMaterial = new THREE.MeshBasicMaterial({
              vertexColors: true,
              transparent: true,
              opacity: 0.8,
              side: THREE.DoubleSide
            });
            
            // Create the trail mesh
            const trailMesh = new THREE.Mesh(tubeGeometry, tubeMaterial);
            scene.add(trailMesh);
            trailMeshes[i] = trailMesh;
            
            // Add a subtle glow effect for more "shooting star" like appearance
            const glowMaterial = new THREE.MeshBasicMaterial({
              color: TRAIL_COLORS[i].start,
              transparent: true,
              opacity: 0.3,
              side: THREE.BackSide
            });
            
            const glowGeometry = new THREE.TubeGeometry(
              curve,
              Math.min(points.length * 2, 200),
              0.25, // slightly larger for the glow
              8,
              false
            );
            
            const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
            trailMesh.add(glowMesh); // Add as a child for easy management
          }
        }
      }

      // ------------------------------------------------
      // Physics simulation
      // ------------------------------------------------
      // Function to calculate body radius based on mass
      function getBodyRadius(mass) {
        return 0.5 + (mass * 0.5); // Same formula used for visual size
      }

      // Update physics
      function updatePhysics(deltaTime) {
        // Calculate gravitational forces between all bodies
        for (let i = 0; i < bodies.length; i++) {
          for (let j = i + 1; j < bodies.length; j++) {
            const body1 = bodies[i];
            const body2 = bodies[j];
            
            // Calculate distance between bodies
              const direction = new THREE.Vector3().subVectors(
              body2.position,
              body1.position
              );
            
              const distance = direction.length();
            
            // Check for collision (sum of radii)
            const body1Radius = getBodyRadius(body1.mass);
            const body2Radius = getBodyRadius(body2.mass);
            
            if (distance < (body1Radius + body2Radius)) {
              handleCollision(i, j);
              return;
            }
            
            // Calculate gravitational force (F = G * m1 * m2 / r^2)
            const forceMagnitude = (G * body1.mass * body2.mass) / (distance * distance);
            
            // Force direction
            const force = direction.normalize().multiplyScalar(forceMagnitude);
            
            // Apply forces (F = ma, so a = F/m)
            const acc1 = force.clone().divideScalar(body1.mass);
            const acc2 = force.clone().multiplyScalar(-1).divideScalar(body2.mass);
            
            body1.velocity.add(acc1.multiplyScalar(deltaTime));
            body2.velocity.add(acc2.multiplyScalar(deltaTime));
          }
        }
        
        // Update positions
        for (let i = 0; i < bodies.length; i++) {
          const body = bodies[i];
          
          // Update position based on velocity
          body.position.add(body.velocity.clone().multiplyScalar(deltaTime));
          
          // Check boundary
          const distanceFromCenter = Math.sqrt(
            body.position.x * body.position.x + 
            body.position.z * body.position.z
          );
          
          // Account for body size when checking boundary
          const bodyRadius = getBodyRadius(body.mass);
          if (distanceFromCenter + bodyRadius > BOUNDARY_RADIUS) {
            handleBoundaryViolation(i);
            return;
          }
          
          // Update mesh position
          bodyMeshes[i].position.copy(body.position);
          
          // Always add the position to trail history - this allows us to show the full path
          // when trails are toggled on, even if they were off during part of the simulation
          body.trail.push(body.position.clone());
        }
        
        // Update trails if they're visible
        if (showTrails) {
        updateTrails();
      }
      }
      
      // Handle collision between bodies
      function handleCollision(index1, index2) {
        if (collisionOccurred) return;
        
        collisionOccurred = true;
        
        // Show reset buttons
        document.getElementById('resetLastButton').style.display = 'inline-block';
        document.getElementById('resetDefaultButton').style.display = 'inline-block';
        
        // Force trails on when collision occurs
        showTrails = true;
        document.getElementById('toggleTrailsButton').textContent = 'Hide Trails';
        
        // Update trails to make them visible
        updateTrails();
        
        isAnimating = false;
        
        // Visual effect for collision
        const collisionPoint = new THREE.Vector3().addVectors(
          bodies[index1].position,
          bodies[index2].position
        ).multiplyScalar(0.5);
        
        createExplosionEffect(collisionPoint);
      }
      
      // Handle body going outside boundary
      function handleBoundaryViolation(index) {
        if (collisionOccurred) return;
        
        collisionOccurred = true;
        
        // Show reset buttons
        document.getElementById('resetLastButton').style.display = 'inline-block';
        document.getElementById('resetDefaultButton').style.display = 'inline-block';
        
        // Force trails on when boundary violation occurs
        showTrails = true;
        document.getElementById('toggleTrailsButton').textContent = 'Hide Trails';
        
        // Update trails to make them visible
        updateTrails();
        
        isAnimating = false;
        
        // Visual effect for boundary violation
        createBoundaryEffect(bodies[index].position);
      }
      
      // Create explosion effect at collision
      function createExplosionEffect(position) {
        const particleCount = 100;
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        
        for (let i = 0; i < particleCount; i++) {
          // Random positions in a sphere
          const x = (Math.random() - 0.5) * 2;
          const y = (Math.random() - 0.5) * 2;
          const z = (Math.random() - 0.5) * 2;
          positions.push(x, y, z);
        }
        
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        
        const material = new THREE.PointsMaterial({
          color: 0xffff00,
          size: 0.2,
          transparent: true
        });
        
        const particles = new THREE.Points(geometry, material);
        particles.position.copy(position);
        scene.add(particles);
        
        // Animation to expand and fade
        const expandAnimation = () => {
          const positionAttr = particles.geometry.attributes.position;
          
          for (let i = 0; i < positionAttr.count; i++) {
            const x = positionAttr.getX(i);
            const y = positionAttr.getY(i);
            const z = positionAttr.getZ(i);
            
            positionAttr.setX(i, x * 1.05);
            positionAttr.setY(i, y * 1.05);
            positionAttr.setZ(i, z * 1.05);
          }
          
          positionAttr.needsUpdate = true;
          material.opacity -= 0.02;
          
          if (material.opacity > 0) {
            requestAnimationFrame(expandAnimation);
          } else {
            scene.remove(particles);
          }
          
          renderer.render(scene, camera);
        };
        
        expandAnimation();
      }
      
      // Create effect for boundary violation
      function createBoundaryEffect(position) {
        const ringGeometry = new THREE.RingGeometry(0.5, 1, 32);
        const ringMaterial = new THREE.MeshBasicMaterial({
          color: 0xff0000,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 1
        });
        
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.position.copy(position);
        ring.lookAt(camera.position); // Face camera
        scene.add(ring);
        
        // Animation to expand and fade
        const expandAnimation = () => {
          ring.scale.x *= 1.05;
          ring.scale.y *= 1.05;
          ring.scale.z *= 1.05;
          ringMaterial.opacity -= 0.02;
          
          if (ringMaterial.opacity > 0) {
            requestAnimationFrame(expandAnimation);
          } else {
            scene.remove(ring);
          }
          
          renderer.render(scene, camera);
        };
        
        expandAnimation();
      }

      // ------------------------------------------------
      // Animation loop
      // ------------------------------------------------
      function animate() {
          animationId = requestAnimationFrame(animate);
        
        if (isAnimating && !isPaused) {
          // Update physics (with constant time step for stability)
          updatePhysics(simulationSpeed);
          
          // Update camera if following
          if (isFollowing) {
            // Determine which body to follow
            let bodyToFollow = bodies[followingBodyIndex || 0];
            const offset = new THREE.Vector3(0, 15, 25);
            camera.position.copy(bodyToFollow.position).add(offset);
            camera.lookAt(bodyToFollow.position);
            controls.target.copy(bodyToFollow.position);
          } else if (cinematicMode) {
            // Apply cinematic camera movement when enabled
            const time = Date.now() * 0.0001;
            camera.position.x = camera.position.x + Math.sin(time) * 0.05;
            camera.position.z = camera.position.z + Math.cos(time) * 0.05;
            camera.lookAt(scene.position);
          }
        }
        
        // Always update controls for smooth camera interaction
          controls.update();
        
        // Render scene
          renderer.render(scene, camera);
        }

      // ------------------------------------------------
      // Core simulation functions
      // ------------------------------------------------
      
      // Handle simulation state changes: start, stop, pause, reset
      function startSimulation() {
        if (collisionOccurred) {
          // Reset to default configuration instead of just resetting to previous state
          resetDefault();
        }
        
        isAnimating = true;
        isPaused = false;
        collisionOccurred = false;
        updateStatusMessage('Running');
        
        // Hide reset buttons when simulation starts
        document.getElementById('resetLastButton').style.display = 'none';
        document.getElementById('resetDefaultButton').style.display = 'none';
        
        // Hide velocity arrows when simulation starts
        for (let i = 0; i < velocityArrows.length; i++) {
          velocityArrows[i].head.visible = false;
          velocityArrows[i].line.visible = false;
        }
      }

      function stopSimulation() {
        // Stop animation
        isAnimating = false;
        isPaused = false;
        simulationTime = 0;
        collisionOccurred = true; // Treat as if collision occurred
        
        // Show reset buttons when stopped
        document.getElementById('resetLastButton').style.display = 'inline-block';
        document.getElementById('resetDefaultButton').style.display = 'inline-block';
        
        // Force trails on when stopped
        showTrails = true;
        document.getElementById('toggleTrailsButton').textContent = 'Hide Trails';
        
        // Update trails to make them visible
        updateTrails();
        
        // Update status
        updateStatusMessage('Stopped');
        
        // Show velocity arrows
        for (let i = 0; i < velocityArrows.length; i++) {
          velocityArrows[i].head.visible = true;
          velocityArrows[i].line.visible = true;
        }
      }
      
      function pauseSimulation() {
        if (!isAnimating) return;
        
        isPaused = !isPaused;
        
        updateStatusMessage(isPaused ? 'Paused' : 'Running');
      }
      
      function resetSimulation() {
        // Stop animation
        isAnimating = false;
        isPaused = false;
        simulationTime = 0;
        collisionOccurred = false;
        
        // Hide reset buttons
        document.getElementById('resetLastButton').style.display = 'none';
        document.getElementById('resetDefaultButton').style.display = 'none';
        
        // Update bodies with current settings
        for (let i = 0; i < 3; i++) {
          bodies[i].position.copy(initialPositions[i]);
          bodies[i].velocity.copy(initialVelocities[i]);
          bodies[i].mass = masses[i];
          
          // Clear previous trail positions but keep the array
          bodies[i].trail = [];
          // Save the initial position into the trail
          bodies[i].trail.push(initialPositions[i].clone());
          
          // Remove old mesh
          scene.remove(bodyMeshes[i]);
          
          // Create new mesh with updated size based on mass
          const size = getBodyRadius(masses[i]);
          const bodyGeometry = new THREE.SphereGeometry(size, 32, 32);
          const bodyMaterial = new THREE.MeshPhongMaterial({
            color: BODY_COLORS[i],
            shininess: 30,
            emissive: new THREE.Color(BODY_COLORS[i]).multiplyScalar(0.2)
          });
          
          const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
          bodyMesh.position.copy(initialPositions[i]);
          bodyMesh.castShadow = true;
          bodyMesh.receiveShadow = true;
          bodyMesh.userData = { 
            bodyIndex: i,
            type: 'body' 
          };
          
          scene.add(bodyMesh);
          bodyMeshes[i] = bodyMesh;
        }
        
        // Update mass sliders to reflect current values
        updateMassSliders();
        
        // Update velocity arrows after body meshes are updated
        for (let i = 0; i < 3; i++) {
          updateVelocityArrow(i);
          velocityArrows[i].head.visible = true;
          velocityArrows[i].line.visible = true;
        }
        
        // Reset trail system
        createTrailSystem();
        
        // Enable orbit controls
        controls.enabled = true;
        
        // Reinitialize drag controls to ensure they're fresh
        setupDragControls();
        
        // Render the reset scene
        renderScene();
      }
      
      // Update status message in a consistent way
      function updateStatusMessage(message) {
        // Status messages are now removed
        console.log("Status: " + message);
      }
      
      // Camera control functions
      function setCamera(position, target) {
        isFollowing = false;
        
        // Disable cinematic mode when changing camera view
        cinematicMode = false;
        document.getElementById('cinematicButton').classList.remove('active');
        
        camera.position.copy(position);
        camera.lookAt(target || new THREE.Vector3(0, 0, 0));
        
        controls.target.copy(target || new THREE.Vector3(0, 0, 0));
        controls.update();
        
        renderScene();
      }
      
      function followBody(bodyIndex) {
        isFollowing = true;
        followingBodyIndex = bodyIndex;
        
        // Disable cinematic mode when following a body
        cinematicMode = false;
        document.getElementById('cinematicButton').classList.remove('active');
        
        const offset = new THREE.Vector3(0, 15, 25);
        camera.position.copy(bodies[bodyIndex].position).add(offset);
        camera.lookAt(bodies[bodyIndex].position);
        
        controls.target.copy(bodies[bodyIndex].position);
        controls.update();
        
        renderScene();
      }
      
      // ------------------------------------------------
      // Event handlers for UI controls
      // ------------------------------------------------
      
      // Set up all event listeners
      function setupEventListeners() {
        // Control panel toggling
        document.getElementById('controlHeader').addEventListener('click', function() {
          const content = document.getElementById('controlContent');
          const toggleButton = document.getElementById('toggleControlsButton');
          content.classList.toggle('collapsed');
          toggleButton.textContent = content.classList.contains('collapsed') ? '▲' : '▼';
        });
        
        // Speed controls toggling
        document.getElementById('speedHeader').addEventListener('click', function() {
          const speedControls = document.getElementById('speedControls');
          const toggleButton = document.getElementById('toggleSpeedButton');
          speedControls.classList.toggle('collapsed');
          toggleButton.textContent = speedControls.classList.contains('collapsed') ? '▲' : '▼';
        });
        
        // Camera controls toggling
        document.getElementById('cameraHeader').addEventListener('click', function() {
          const cameraControls = document.getElementById('camera-controls');
          const toggleButton = document.getElementById('toggleCameraButton');
          cameraControls.classList.toggle('collapsed');
          toggleButton.textContent = cameraControls.classList.contains('collapsed') ? '▲' : '▼';
        });
        
        // Mass controls toggling
        document.getElementById('massHeader').addEventListener('click', function() {
          const massControls = document.getElementById('mass-controls');
          const toggleButton = document.getElementById('toggleMassButton');
          massControls.classList.toggle('collapsed');
          toggleButton.textContent = massControls.classList.contains('collapsed') ? '▲' : '▼';
        });
        
        // Simulation controls
        document.getElementById('startButton').addEventListener('click', startSimulation);
        document.getElementById('stopButton').addEventListener('click', stopSimulation);
        document.getElementById('resetLastButton').addEventListener('click', resetSimulation);
        document.getElementById('resetDefaultButton').addEventListener('click', resetDefault);
        document.getElementById('pauseButton').addEventListener('click', pauseSimulation);
        
        // Trail toggle
        document.getElementById('toggleTrailsButton').addEventListener('click', function() {
          showTrails = !showTrails;
          
          document.getElementById('toggleTrailsButton').textContent = 
            showTrails ? 'Hide Trails' : 'Show Trails';
          
          // If showing trails, update them to show the full path
          if (showTrails) {
            updateTrails();
          } else {
            // Hide trails by removing them from scene
          for (let i = 0; i < 3; i++) {
              if (trailMeshes[i]) {
                scene.remove(trailMeshes[i]);
                trailMeshes[i] = null;
              }
            }
          }
          
          renderScene();
        });
        
        // Camera views
        document.getElementById('topViewButton').addEventListener('click', function() {
          setCamera(new THREE.Vector3(0, 75, 0.1));
        });
        
        document.getElementById('sideViewButton').addEventListener('click', function() {
          setCamera(new THREE.Vector3(75, 0, 0));
        });
        
        document.getElementById('angledViewButton').addEventListener('click', function() {
          setCamera(new THREE.Vector3(50, 50, 50));
        });
        
        // Follow body controls
        document.getElementById('followBody1Button').addEventListener('click', function() {
          followBody(0);
        });
        
        document.getElementById('followBody2Button').addEventListener('click', function() {
          followBody(1);
        });
        
        document.getElementById('followBody3Button').addEventListener('click', function() {
          followBody(2);
        });
        
        // Cinematic mode toggle
        document.getElementById('cinematicButton').addEventListener('click', function() {
          cinematicMode = !cinematicMode;
          this.classList.toggle('active');
          
          if (cinematicMode) {
            // If following a body, disable cinematic mode
            if (isFollowing) {
              this.classList.remove('active');
              cinematicMode = false;
              alert('Cinematic mode is disabled when following a body.');
            } else {
              updateStatusMessage('Cinematic Mode Enabled');
            }
          } else {
            updateStatusMessage('Cinematic Mode Disabled');
          }
        });
        
        // Speed controls
        document.getElementById('slowSpeedButton').addEventListener('click', function() {
          simulationSpeed = 0.15;
          updateStatusMessage('Slow Speed');
          updateSpeedButtonStyles(this);
        });
        
        document.getElementById('normalSpeedButton').addEventListener('click', function() {
          simulationSpeed = 0.25;
          updateStatusMessage('Normal Speed');
          updateSpeedButtonStyles(this);
        });
        
        document.getElementById('fastSpeedButton').addEventListener('click', function() {
          simulationSpeed = 0.6; // Even faster
          updateStatusMessage('Fast Speed');
          updateSpeedButtonStyles(this);
        });
        
        document.getElementById('veryFastSpeedButton').addEventListener('click', function() {
          simulationSpeed = 1.2; // Very fast simulation
          updateStatusMessage('Very Fast Speed');
          updateSpeedButtonStyles(this);
        });
        
        document.getElementById('superFastSpeedButton').addEventListener('click', function() {
          simulationSpeed = 2.0; // Super fast simulation
          updateStatusMessage('Super Fast Speed');
          updateSpeedButtonStyles(this);
        });
        
        // Update the speed button styles to show which one is active
        function updateSpeedButtonStyles(activeButton) {
          document.querySelectorAll('.speed-button').forEach(button => {
            button.classList.remove('speed-active');
          });
          activeButton.classList.add('speed-active');
        }
        
        // Window resize handler
        window.addEventListener('resize', handleWindowResize);
      }
      
      // Handle window resize
      function handleWindowResize() {
        // Determine new size based on window dimensions and 16:9 aspect ratio
        let newWidth, newHeight;
        if (window.innerWidth / window.innerHeight > aspectRatio) {
          // Window is wider than 16:9
          newHeight = window.innerHeight;
          newWidth = newHeight * aspectRatio;
        } else {
          // Window is taller than 16:9
          newWidth = window.innerWidth;
          newHeight = newWidth / aspectRatio;
        }
        
        // Update camera
        camera.aspect = aspectRatio;
        camera.updateProjectionMatrix();
        
        // Update renderer
        renderer.setSize(newWidth, newHeight);
        
        // Render the scene
        renderScene();
      }
      
      // Initial setup and scene initialization
      function initScene() {
        // Set up default configuration
        // Central star with two orbiting bodies
        initialPositions[0].set(-5, 0, 0);     // Left body
        initialPositions[1].set(5, 0, 0);      // Right body
        initialPositions[2].set(0, 0, 0);      // Center body
        
        initialVelocities[0].set(0, 0, 0.42);  // Left body moving up
        initialVelocities[1].set(0, 0, -0.42); // Right body moving down
        initialVelocities[2].set(0, 0, 0);     // Center body stationary
        
        masses[0] = 1.0;  // Left body mass
        masses[1] = 1.0;  // Right body mass
        masses[2] = 1.5;  // Center body mass (heavier)
        
        // Create bodies
        createBodies();
        
        // Set up real-time parameter updates
        setupRealTimeUpdates();
        
        // Set up event listeners
        setupEventListeners();
        
        // Set initial camera to angled view for best initial appearance
        setCamera(new THREE.Vector3(50, 50, 50));
        
        // Ensure camera is looking at origin
          camera.lookAt(0, 0, 0);
        controls.target.set(0, 0, 0);
          controls.update();
        
        // Reset simulation state
        resetSimulation();
        
        // Force an initial render to ensure everything is visible
        renderScene();
      }
      
      // Start the initialization
      initScene();

      // Start the animation loop to keep controls responsive
      animate();

      // Helper function for rendering
      function renderScene() {
        renderer.render(scene, camera);
      }
      
      // Real-time update of parameters without needing to click "Apply"
      function setupRealTimeUpdates() {
        // Mass sliders
        document.getElementById('body1MassSlider').addEventListener('input', function() {
          const value = parseFloat(this.value);
          document.getElementById('body1MassValue').textContent = value.toFixed(1);
          document.getElementById('body1Mass').value = value; // Update hidden input
          updateBodyMass(0, value);
        });
        
        document.getElementById('body2MassSlider').addEventListener('input', function() {
          const value = parseFloat(this.value);
          document.getElementById('body2MassValue').textContent = value.toFixed(1);
          document.getElementById('body2Mass').value = value; // Update hidden input
          updateBodyMass(1, value);
        });
        
        document.getElementById('body3MassSlider').addEventListener('input', function() {
          const value = parseFloat(this.value);
          document.getElementById('body3MassValue').textContent = value.toFixed(1);
          document.getElementById('body3Mass').value = value; // Update hidden input
          updateBodyMass(2, value);
        });
      }
      
      // Helper function to update mass
      function updateBodyMass(bodyIndex, massValue) {
        // Update mass value
        masses[bodyIndex] = massValue;
        bodies[bodyIndex].mass = massValue;
        
        // Update visual size to match mass
        const size = getBodyRadius(massValue);
        
        // Remove old mesh
        scene.remove(bodyMeshes[bodyIndex]);
        
        // Create new mesh with updated size
        const bodyGeometry = new THREE.SphereGeometry(size, 32, 32);
        const bodyMaterial = new THREE.MeshPhongMaterial({
          color: BODY_COLORS[bodyIndex],
          shininess: 30,
          emissive: new THREE.Color(BODY_COLORS[bodyIndex]).multiplyScalar(0.2)
        });
        
        const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
        bodyMesh.position.copy(bodies[bodyIndex].position);
        bodyMesh.castShadow = true;
        bodyMesh.receiveShadow = true;
        bodyMesh.userData = { 
          bodyIndex: bodyIndex,
          type: 'body' 
        };
        
        scene.add(bodyMesh);
        bodyMeshes[bodyIndex] = bodyMesh;
        
        // Update drag controls
        setupDragControls();
        
        // Render the scene to reflect changes
        renderScene();
      }
      
      // Helper function to update velocity
      function updateBodyVelocity(bodyIndex, component, value) {
        if (component === 'x') {
          initialVelocities[bodyIndex].x = value;
          bodies[bodyIndex].velocity.x = value;
        } else if (component === 'z') {
          initialVelocities[bodyIndex].z = value;
          bodies[bodyIndex].velocity.z = value;
        }
        
        // Update velocity arrow
        updateVelocityArrow(bodyIndex);
        
        // Render the scene to reflect changes
        renderScene();
      }

      // Reset to the default configuration
      function resetDefault() {
        // Stop animation
        isAnimating = false;
        isPaused = false;
        simulationTime = 0;
        collisionOccurred = false;
        
        // Hide reset buttons
        document.getElementById('resetLastButton').style.display = 'none';
        document.getElementById('resetDefaultButton').style.display = 'none';
        
        // Set up default configuration
        // Central star with two orbiting bodies
        initialPositions[0].set(-5, 0, 0);     // Left body
        initialPositions[1].set(5, 0, 0);      // Right body
        initialPositions[2].set(0, 0, 0);      // Center body
        
        initialVelocities[0].set(0, 0, 0.42);  // Left body moving up
        initialVelocities[1].set(0, 0, -0.42); // Right body moving down
        initialVelocities[2].set(0, 0, 0);     // Center body stationary
        
        masses[0] = 1.0;  // Left body mass
        masses[1] = 1.0;  // Right body mass
        masses[2] = 1.5;  // Center body mass (heavier)
        
        // Update bodies with default settings
        for (let i = 0; i < 3; i++) {
          bodies[i].position.copy(initialPositions[i]);
          bodies[i].velocity.copy(initialVelocities[i]);
          bodies[i].mass = masses[i];
          
          // Clear previous trail positions but keep the array
          bodies[i].trail = [];
          // Save the initial position into the trail
          bodies[i].trail.push(initialPositions[i].clone());
          
          // Remove old mesh
          scene.remove(bodyMeshes[i]);
          
          // Create new mesh with updated size based on mass
          const size = getBodyRadius(masses[i]);
          const bodyGeometry = new THREE.SphereGeometry(size, 32, 32);
          const bodyMaterial = new THREE.MeshPhongMaterial({
            color: BODY_COLORS[i],
            shininess: 30,
            emissive: new THREE.Color(BODY_COLORS[i]).multiplyScalar(0.2)
          });
          
          const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
          bodyMesh.position.copy(initialPositions[i]);
          bodyMesh.castShadow = true;
          bodyMesh.receiveShadow = true;
          bodyMesh.userData = { 
            bodyIndex: i,
            type: 'body' 
          };
          
          scene.add(bodyMesh);
          bodyMeshes[i] = bodyMesh;
        }
        
        // Update mass sliders to reflect default values
        updateMassSliders();
        
        // Update velocity arrows after body meshes are updated
        for (let i = 0; i < 3; i++) {
          updateVelocityArrow(i);
          velocityArrows[i].head.visible = true;
          velocityArrows[i].line.visible = true;
        }
        
        // Reset trail system
        createTrailSystem();
        
        // Enable orbit controls
        controls.enabled = true;
        
        // Reinitialize drag controls to ensure they're fresh
        setupDragControls();
        
        // Render the reset scene
        renderScene();
      }
    </script>
  </body>
</html>
